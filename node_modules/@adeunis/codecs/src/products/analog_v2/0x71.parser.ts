namespace codec {
  /**
   * Analog V2 0x71 (data) frame parser
   */
  export class Analog20x71Parser implements FrameParser {
    readonly deviceType = 'analog2';
    readonly frameCode = 0x71;

    public parseFrame(payload: Buffer, configuration: Buffer, network: Network) {
      const appContent: Content = { type: '0x71 Analog V2 periodic data' };
      let rawValue;
      const channels: Content = [];
      const ch1 = [],
        ch2 = [];

      const nbSensors = (payload[2] & 0x01 ? 1 : 0) + (payload[2] & 0x04 ? 1 : 0);
      const payloadLength = payload[1] & 0x04 ? payload.length - 4 : payload.length;

      // Loop through historic data [t=0, t-1, t-2,...]
      // we subtract 4 bytes from the total length of the frame to deduce the timestamp
      for (let offset = 3; offset < payloadLength; offset += 2 * nbSensors) {
        rawValue = payload.readUInt16BE(offset);
        ch1.push(rawValue / 1000);

        if (nbSensors === 2) {
          rawValue = payload.readUInt16BE(offset + 2);
          ch2.push(rawValue / 1000);
        }
      }

      if (payload[1] & 0x04) {
        // retrieval of the frame date timestamp value, then conversion to epoch 2013 (+1356998400), then in second
        const myDate = new Date((payload.readUInt32BE(payload.length - 4) + 1356998400) * 1000);
        // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
        appContent['timestamp'] = myDate.toJSON().replace('Z', '');
      }

      appContent['decodingInfo'] = 'values: [t=0, t-1, t-2, ...]';

      //Only channel B is active
      if (nbSensors == 1 && payload[2] & 0x04) {
        channels['push']({ name: 'channel B', unit: payload[2] & 0x08 ? 'mA' : 'V', values: ch1 });
      } else {
        channels['push']({ name: 'channel A', unit: payload[2] & 0x02 ? 'mA' : 'V', values: ch1 });
      }

      if (nbSensors === 2) {
        channels['push']({ name: 'channel B', unit: payload[2] & 0x08 ? 'mA' : 'V', values: ch2 });
      }
      appContent['channels'] = channels;

      return appContent;
    }
  }
}
