namespace codec {
  /**
   * Temp 4 0x30 (keep alive) frame parser
   */
  export class TempV40x30Parser implements FrameParser {
    readonly deviceType = 'temp4';
    readonly frameCode = 0x30;

    public parseFrame(payload: Buffer, configuration: Buffer, network: Network) {
      const appContent: Content = { type: '0x30 Temp 4 keep alive' };
      const nbSensors = payload[1] & 0x10 ? 2 : 1;
      if (payload[1] & 0x04) {
        // offsetType for date timestamp position
        const offsetType = nbSensors === 2 ? 6 : 4;
        // retrieval of the frame date timestamp value, then conversion to epoch 2013 (+1356998400), then in second
        const myDate = new Date((payload.readUInt32BE(offsetType) + 1356998400) * 1000);
        // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
        appContent['timestamp'] = myDate.toJSON().replace('Z', '');
      }

      const temperatures: Content = [];
      // value@-3276.8 must be considered as an invalid measure (probe disconnected for instance)
      temperatures['push']({ name: 'temperature 1', unit: '\u00B0' + 'C', value: payload.readInt16BE(2) / 10 });
      if (nbSensors === 2) {
        temperatures['push']({ name: 'temperature 2', unit: '\u00B0' + 'C', value: payload.readInt16BE(4) / 10 });
      }
      appContent['temperatures'] = temperatures;
      return appContent;
    }
  }
}
