namespace codec {
  /**
   * Pulse 4 0x30 (keep alive) frame parser
   */
  export class PulseV4NbIot0x30Parser implements FrameParser {
    readonly deviceType = 'pulse4nbiot';
    readonly frameCode = 0x30;

    // Offset to add in order to jump NB-Iot additional header
    readonly hOffset = 13;

    public parseFrame(payload: Buffer, configuration: Buffer, network: Network) {
      const appContent: Content = { type: '0x30 Pulse 4 NB-IoT keep alive' };

      if (payload[this.hOffset + 1] & 0x04) {
        // retrieval of the frame date timestamp value, then conversion to epoch 2013 (+1356998400), then in second
        const myDate = new Date((payload.readUInt32BE(this.hOffset + 11) + 1356998400) * 1000);
        // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
        appContent['timestamp'] = myDate.toJSON().replace('Z', '');
      }

      const chA: Content = { name: 'channel A' };
      const chB: Content = { name: 'channel B' };

      chA['flow'] = {
        alarm: Boolean(payload[this.hOffset + 2] & 0x01),
        last24hMin: payload.readUInt16BE(this.hOffset + 7),
        last24hMax: payload.readUInt16BE(this.hOffset + 3),
      };
      chA['tamperAlarm'] = Boolean(payload[this.hOffset + 2] & 0x04);
      chA['leakageAlarm'] = Boolean(payload[this.hOffset + 2] & 0x10);

      chB['flow'] = {
        alarm: Boolean(payload[this.hOffset + 2] & 0x02),
        last24hMin: payload.readUInt16BE(this.hOffset + 9),
        last24hMax: payload.readUInt16BE(this.hOffset + 5),
      };
      chB['tamperAlarm'] = Boolean(payload[this.hOffset + 2] & 0x08);
      chB['leakageAlarm'] = Boolean(payload[this.hOffset + 2] & 0x20);

      appContent['channels'] = [chA, chB];

      return appContent;
    }
  }
}
