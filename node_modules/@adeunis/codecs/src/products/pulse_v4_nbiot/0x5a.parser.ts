namespace codec {
  /**
   * Pulse 4 periodic data  frame parser
   */
  export class PulseV4NbIot0x5aParser implements FrameParser {
    readonly deviceType = 'pulse4nbiot';
    readonly frameCode = 0x5a;

    // Offset to add in order to jump NB-Iot additional header
    readonly hOffset = 13;

    public parseFrame(payload: Buffer, configuration: Buffer, network: Network) {
      let absCounterValue = payload.readUInt32BE(this.hOffset + 2);
      const appContent: Content = { type: '0x5a Pulse 4 NB-IoT data - channel A' };
      const values = [absCounterValue];
      const payloadLength = payload[this.hOffset + 1] & 0x04 ? payload.length - 4 : payload.length;

      if (payload[this.hOffset + 1] & 0x04) {
        // retrieval of the frame date timestamp value, then conversion to epoch 2013 (+1356998400), then in second
        const myDate = new Date((payload.readUInt32BE(payload.length - 4) + 1356998400) * 1000);
        // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
        appContent['timestamp'] = myDate.toJSON().replace('Z', '');
      }
      // Loop through historic data [t=0, t-1, t-2,...]
      for (let offset = this.hOffset + 6; offset < payloadLength; offset += 2) {
        absCounterValue -= payload.readUInt16BE(offset);
        values.push(absCounterValue);
      }

      appContent['decodingInfo'] = 'counterValues: [t=0, t-1, t-2, ...]';
      appContent['counterValues'] = values;

      return appContent;
    }

    /**
     * Get reading frequency
     * @param configuration configuration
     */
    private getReadingFrequency(configuration: Buffer) {
      return configuration.byteLength > 0 ? configuration.readUInt16BE(8) * configuration.readUInt16BE(6) * 2 : null;
    }
  }
}
