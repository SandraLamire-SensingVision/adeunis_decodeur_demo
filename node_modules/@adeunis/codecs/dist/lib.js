"use strict";
var codec;
(function (codec) {
    /**
     * Decoder class.
     *
     * Main class for decoding purposes.
     * Contains declaration of all required parsers and decode() method (API entry point).
     *
     * See below for explanations on parsers.
     */
    class Decoder {
        /**
         * Parsers declaration.
         *
         * Array of parser implementations that can be used by the library.
         *
         * Parsers are specific handlers for parsing frame of a device type and a frame code.
         */
        parsers = [
            // 1. Generic parsers not used for REPEATER
            // 2. GenericStatusByteParser() must be allocated only by custom parser.
            // => Default status byte parser must be GenericStatusByteExtParser()
            // new GenericStatusByteParser(),
            new codec.GenericStatusByteExtParser(),
            new codec.Generic0x1fParser(),
            new codec.Generic0x20Parser(),
            new codec.Generic0x2fParser(),
            new codec.Generic0x30Parser(),
            new codec.Generic0x33Parser(),
            new codec.Generic0x36Parser(),
            new codec.Generic0x37Parser(),
            new codec.Generic0x51Parser(),
            new codec.Generic0x52Parser(),
            // DRYCONTACTS product
            new codec.DrycontactsStatusByteParser(),
            new codec.Drycontacts0x10Parser(),
            new codec.Drycontacts0x40Parser(),
            // DRYCONTACTS 2 product
            new codec.Drycontacts2StatusByteParser(),
            new codec.Drycontacts20x10Parser(),
            new codec.Drycontacts20x30Parser(),
            new codec.Drycontacts20x40Parser(),
            new codec.Drycontacts20x41Parser(),
            new codec.Drycontacts20x59Parser(),
            // PULSE product
            new codec.PulseStatusByteParser(),
            new codec.Pulse0x10Parser(),
            new codec.Pulse0x11Parser(),
            new codec.Pulse0x12Parser(),
            new codec.Pulse0x30Parser(),
            new codec.Pulse0x46Parser(),
            new codec.Pulse0x47Parser(),
            new codec.Pulse0x48Parser(),
            // Pulse 3 product
            new codec.PulseV30x10Parser(),
            new codec.PulseV30x11Parser(),
            new codec.PulseV30x12Parser(),
            new codec.PulseV30x30Parser(),
            new codec.PulseV30x46Parser(),
            new codec.PulseV30x47Parser(),
            new codec.PulseV30x5aParser(),
            new codec.PulseV30x5bParser(),
            // Pulse 4 product
            new codec.PulseV4StatusByteParser(),
            new codec.PulseV40x10Parser(),
            new codec.PulseV40x11Parser(),
            new codec.PulseV40x12Parser(),
            new codec.PulseV40x30Parser(),
            new codec.PulseV40x46Parser(),
            new codec.PulseV40x47Parser(),
            new codec.PulseV40x5aParser(),
            new codec.PulseV40x5bParser(),
            // Pulse 4 NB-IoT product
            new codec.PulseV4NbIotStatusByteParser(),
            new codec.PulseV4NbIot0x10Parser(),
            new codec.PulseV4NbIot0x20Parser(),
            new codec.PulseV4NbIot0x30Parser(),
            new codec.PulseV4NbIot0x33Parser(),
            new codec.PulseV4NbIot0x46Parser(),
            new codec.PulseV4NbIot0x47Parser(),
            new codec.PulseV4NbIot0x5aParser(),
            new codec.PulseV4NbIot0x5bParser(),
            // TEMP product
            new codec.TempStatusByteParser(),
            new codec.Temp0x10Parser(),
            new codec.Temp0x11Parser(),
            new codec.Temp0x12Parser(),
            new codec.Temp0x30Parser(),
            new codec.Temp0x43Parser(),
            // Temp 3 product
            new codec.TempV3StatusByteParser(),
            new codec.TempV30x10Parser(),
            new codec.TempV30x30Parser(),
            new codec.TempV30x57Parser(),
            new codec.TempV30x58Parser(),
            // temp 4 product
            new codec.TempV4StatusByteParser(),
            new codec.TempV40x10Parser(),
            new codec.TempV40x30Parser(),
            new codec.TempV40x57Parser(),
            new codec.TempV40x58Parser(),
            // COMFORT product
            new codec.Comfort0x10Parser(),
            new codec.Comfort0x4cParser(),
            new codec.Comfort0x4dParser(),
            // COMFORT 2 product
            new codec.Comfort2StatusByteParser(),
            new codec.Comfort20x10Parser(),
            new codec.Comfort20x4cParser(),
            new codec.Comfort20x4dParser(),
            // COMFORT Co2 product
            new codec.ComfortCo2StatusByteParser(),
            new codec.ComfortCo20x10Parser(),
            new codec.ComfortCo20x6aParser(),
            new codec.ComfortCo20x6bParser(),
            new codec.ComfortCo20x30Parser(),
            // COMFORT SERENITY
            new codec.ComfortSerenityStatusByteParser(),
            new codec.ComfortSerenity0x10Parser(),
            new codec.ComfortSerenity0x30Parser(),
            new codec.ComfortSerenity0x31Parser(),
            new codec.ComfortSerenity0x38Parser(),
            new codec.ComfortSerenity0x6aParser(),
            new codec.ComfortSerenity0x6bParser(),
            new codec.ComfortSerenity0x6fParser(),
            new codec.ComfortSerenity0x70Parser(),
            // MODBUS product
            new codec.ModbusStatusByteParser(),
            new codec.Modbus0x10Parser(),
            new codec.Modbus0x44Parser(),
            new codec.Modbus0x45Parser(),
            new codec.Modbus0x5eParser(),
            new codec.Modbus0x5fParser(),
            new codec.Modbus0x60Parser(),
            new codec.Modbus0x61Parser(),
            new codec.Modbus0x62Parser(),
            new codec.Modbus0x63Parser(),
            // MOTION product
            new codec.Motion0x10Parser(),
            new codec.Motion0x4eParser(),
            new codec.Motion0x4fParser(),
            new codec.Motion0x50Parser(),
            new codec.Motion0x5cParser(),
            new codec.Motion0x5dParser(),
            // REPEATER product
            new codec.RepeaterStatusByteParser(),
            new codec.Repeater0x01Parser(),
            new codec.Repeater0x02Parser(),
            new codec.Repeater0x03Parser(),
            new codec.Repeater0x04Parser(),
            // DELTAP product
            new codec.Deltap0x10Parser(),
            new codec.Deltap0x11Parser(),
            new codec.Deltap0x2fParser(),
            new codec.Deltap0x53Parser(),
            new codec.Deltap0x54Parser(),
            new codec.Deltap0x55Parser(),
            new codec.Deltap0x56Parser(),
            // Analog product
            new codec.AnalogStatusByteParser(),
            new codec.Analog0x10Parser(),
            new codec.Analog0x11Parser(),
            new codec.Analog0x12Parser(),
            new codec.Analog0x13Parser(),
            new codec.Analog0x14Parser(),
            new codec.Analog0x30Parser(),
            new codec.Analog0x42Parser(),
            // Analog V2 product
            new codec.Analog2StatusByteParser(),
            new codec.Analog20x10Parser(),
            new codec.Analog20x30Parser(),
            new codec.Analog20x38Parser(),
            new codec.Analog20x42Parser(),
            new codec.Analog20x71Parser(),
            new codec.Analog20x72Parser(),
            // TIC product
            new codec.TicStatusByteParser(),
            new codec.Tic0x10Parser(),
            new codec.Tic0x49Parser(),
            new codec.Tic0x4aParser(),
            // Breath product
            new codec.BreathStatusByteParser(),
            new codec.Breath0x6dParser(),
            new codec.Breath0x6eParser(),
            new codec.Breath0x10Parser(),
            new codec.Breath0x30Parser(),
        ];
        /**
         * Codec storage
         */
        codecStorage;
        /**
         * Constructor
         * @param options option object
         *   option.codecStorage: implementation of CodecStorage to use for external storage, leave blank if unknown
         */
        constructor(options) {
            if (options && options.codecStorage) {
                // External storage: Node-RED...
                this.codecStorage = options.codecStorage;
            }
            else if (typeof localStorage !== 'undefined') {
                // Local storage: browser
                this.codecStorage = localStorage;
            }
            else {
                // Default (JS object)
                this.codecStorage = new codec.InternalCodecStorage();
            }
            // TODO: check parsers uniqueness
        }
        /**
         * Get supported device types and frame codes.
         *
         * The returned pairs are available for decoding.
         */
        getSupported() {
            const list = [];
            this.parsers.map(p => p.deviceType.split('|').map(q => list.push({
                deviceType: q,
                frameCode: p.frameCode,
            })));
            return list;
        }
        /**
         * Find device types
         * @param payloadString payload as hexadecimal string
         */
        findDeviceTypes(payloadString) {
            // Check arguments
            if (!/^(?:[0-9a-f]{2}){2,}$/gi.test(payloadString)) {
                return [];
            }
            // Get buffer and frame code
            const payload = Buffer.from(payloadString, 'hex');
            const frameCode = payload[0];
            const deviceTypesFull = this.parsers.filter(p => p.frameCode === frameCode).map(p => p.deviceType);
            return Array.from(new Set(deviceTypesFull));
        }
        /**
         * Decode given payload.
         * @param payloadString payload as hexadecimal string
         * @param devId device ID: LoRa device EUI or Sigfox ID, leave blank if unknown
         * @param network network: lora868 or sigfox
         * @returns decoded data as JSON object
         */
        decode(payloadString, devId = 'tmpDevId', network = 'unknown') {
            // Check arguments
            if (!/^(?:[0-9a-f]{2}){2,}$/gi.test(payloadString)) {
                return { type: 'Invalid' };
            }
            // Get buffer and frame code
            const payload = Buffer.from(payloadString, 'hex');
            let frameCode = payload[0];
            // Handle device type
            const deviceType = this.fetchDeviceType(devId);
            // Specific hook for NB-IoT products that have an additional header (13 bytes) before classic frame content
            if (deviceType === 'pulse4nbiot') {
                frameCode = payload[13 + 0];
            }
            // Handle configuration
            let configuration;
            if (frameCode === 0x10) {
                configuration = payload;
                this.storeConfiguration(configuration, devId);
            }
            else {
                configuration = this.fetchConfiguration(devId);
            }
            // Handle specific parsing
            const activeParsers = this.getActiveParsers(deviceType, frameCode);
            const partialContents = activeParsers.map(p => {
                let partialContent;
                try {
                    partialContent = p.parseFrame(payload, configuration, network, deviceType);
                }
                catch (error) {
                    partialContent = { error: error.toString() };
                }
                return partialContent;
            });
            // Handle unsupported
            if (activeParsers.every(p => p.frameCode < 0)) {
                partialContents.push({ type: 'Unsupported' });
            }
            // Merge partial contents
            let content = Object.assign({}, ...partialContents);
            // Put 'type' at first position
            const typestr = content['type'];
            delete content['type'];
            content = Object.assign({ type: typestr }, content);
            return content;
        }
        /**
         * Set device type for given device ID.
         *
         * Gives additional information to the library to provide better decoding.
         * The library can also guess device type from passed frames in decode() method. Use this method when the frame
         * to decode does not refer to a single device type (example: 0x10 frames).
         *
         * @param deviceType device type, must be a value from getSupported() method
         * @param devId device ID: LoRa device EUI or Sigfox ID
         */
        setDeviceType(deviceType, devId = 'tmpDevId') {
            this.codecStorage.setItem(`${devId}.deviceType`, deviceType);
        }
        /**
         * Clear stored data for a device ID:
         *   - Device type
         *   - Configuration
         * @param devId device ID: LoRa device EUI or Sigfox ID, leave blank if unknown
         */
        clearStoredData(devId) {
            if (!devId) {
                devId = 'tmpDevId';
            }
            ['deviceType', 'configuration'].map(suffix => `${devId}.${suffix}`).forEach(key => this.codecStorage.removeItem(key));
        }
        /**
         * Fetch configuration frame
         * @param devId device ID
         */
        fetchConfiguration(devId) {
            if (!devId) {
                return Buffer.from('');
            }
            const value = this.codecStorage.getItem(`${devId}.configuration`);
            return Buffer.from(value || '', 'hex');
        }
        /**
         * Store configuration frame
         * @param payload payload
         * @param devId device ID
         */
        storeConfiguration(payload, devId) {
            if (!devId) {
                return payload;
            }
            this.codecStorage.setItem(`${devId}.configuration`, payload.toString('hex'));
            return payload;
        }
        /**
         * Fetch device type
         * @param devId device ID
         */
        fetchDeviceType(devId) {
            if (!devId) {
                return '';
            }
            return this.codecStorage.getItem(`${devId}.deviceType`) || '';
        }
        /**
         * Store device type
         * @param frameCode frame code
         * @param devId device ID
         */
        storeDeviceType(frameCode, devId) {
            let deviceType = '';
            if (!devId) {
                return deviceType;
            }
            const matchingParsers = this.parsers.filter(p => p.deviceType !== 'any' && p.frameCode === frameCode);
            if (matchingParsers.length === 1) {
                deviceType = matchingParsers[0].deviceType;
                this.codecStorage.setItem(`${devId}.deviceType`, deviceType);
            }
            return deviceType;
        }
        /**
         * Analyze deviceType string of the specified parser and check if it's compatible
         * @param parser parser to check
         * @param deviceType deviceType to check
         */
        isCompatibleDeviceType(parser, deviceType) {
            // A parser may support a list of devices (string split with '|'). Do not include 'any' parsers (managed later)
            const list = parser.deviceType.split('|').filter(q => q === deviceType);
            return list.length > 0;
        }
        /**
         * Get active parsers
         * @param deviceType device type
         * @param frameCode frame code
         */
        getActiveParsers(deviceType, frameCode) {
            let activeParsers = [];
            // Behavior: find if a specific parser exists for this deviceType
            //           otherwise try to find a ganeric parser
            //           if at least one parser has been found, add a status byte parser (specific or generic)
            // Device type is known, get parsers for given device type AND frame code
            let dataParser = this.parsers.filter(p => this.isCompatibleDeviceType(p, deviceType) && (p.frameCode < 0 || p.frameCode === frameCode));
            // If not custom decoder found, use a generic one
            // Repeater has only specific parsers. Do not add generic ones
            if (dataParser.length === 0 && deviceType !== 'repeater') {
                const genericParsers = this.parsers.filter(p => p.deviceType === 'any' && (p.frameCode < 0 || p.frameCode === frameCode));
                dataParser = activeParsers.concat(genericParsers);
            }
            // Find the status byte parser: only if the frame is managed
            if (dataParser.length > 0) {
                const statusByteParsers = this.parsers.filter(p => this.isCompatibleDeviceType(p, deviceType) && p.frameCode === 0);
                activeParsers = activeParsers.concat(statusByteParsers);
                if (statusByteParsers.length === 0) {
                    const genericStatusByteParsers = this.parsers.filter(p => p.deviceType === 'any' && p.frameCode === 0);
                    activeParsers = activeParsers.concat(genericStatusByteParsers);
                }
            }
            // Status parser must be first in list for a better display
            activeParsers = activeParsers.concat(dataParser);
            // Return active parser
            return activeParsers;
        }
    }
    codec.Decoder = Decoder;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Encoder class.
     *
     * Main class for encoding purposes.
     * Contains declaration of all required builders and encode() method (API entry point).
     *
     * See below for explanations on builders.
     */
    class Encoder {
        /**
         * Builders declaration.
         *
         * Array of builder implementations that can be used by the library.
         *
         * Builders are specific handlers for encoding frame of a device type and a frame code.
         */
        builders = [
            new codec.Repeater0x01Builder(),
            new codec.Repeater0x02Builder(),
            new codec.Repeater0x03Builder(),
            new codec.Repeater0x04Builder(),
            new codec.Repeater0x05Builder(),
        ];
        /**
         * Get supported device types and frame codes.
         *
         * The returned pairs are available for encoding.
         */
        getSupported() {
            return this.builders.map(p => ({
                deviceType: p.deviceType,
                frameCode: p.frameCode,
            }));
        }
        /**
         * Get input data types.
         * @param deviceType device type
         * @param frameCode frame code
         * @returns a map of available input data and associated types
         */
        getInputDataTypes(deviceType, frameCode) {
            const builder = this.builders.find(b => b.deviceType === deviceType && b.frameCode === frameCode);
            if (!builder) {
                return {};
            }
            const inputdataTypes = {};
            const inputData = new builder.inputDataClass();
            for (const key in inputData) {
                if (Object.prototype.hasOwnProperty.call(inputData, key)) {
                    inputdataTypes[key] = typeof inputData[key];
                }
            }
            return inputdataTypes;
        }
        /**
         * Encode given arguments.
         *
         * Generates a string payload from given arguments. Data object members and associated types can be known using
         * getInputDataTypes() method.
         *
         * @param deviceType device type
         * @param frameCode frame code
         * @param network network: lora868 or sigfox
         * @param data data object: map of available input data and values
         * @returns encoded data as string
         */
        encode(deviceType, frameCode, network = 'unknown', data) {
            const builder = this.builders.find(b => b.deviceType === deviceType && b.frameCode === frameCode);
            if (!builder) {
                return '';
            }
            const payload = builder.buildFrame(data || new builder.inputDataClass(), network);
            return payload.toString('hex');
        }
    }
    codec.Encoder = Encoder;
})(codec || (codec = {}));
// CommonJS
if (typeof module !== 'undefined') {
    module.exports = codec;
}
// Test (Mocha)
if (typeof process !== 'undefined' && process.env['NODE_ENV'] === 'test') {
    global.codec = codec;
}
var codec;
(function (codec) {
    /**
     * Internal codec storage
     */
    class InternalCodecStorage {
        store = {};
        getItem(key) {
            return this.store[key];
        }
        removeItem(key) {
            delete this.store[key];
        }
        setItem(key, value) {
            this.store[key] = value;
        }
    }
    codec.InternalCodecStorage = InternalCodecStorage;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Analog 0x10 (configuration) frame parser
     */
    class Analog0x10Parser {
        deviceType = 'analog';
        frameCode = 0x10;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x10 Analog configuration' };
            const ch1 = { name: 'channel A' };
            const ch2 = { name: 'channel B' };
            if (payload[8] === 2) {
                // TEST mode => period = value * 20sec
                appContent['transmissionPeriodKeepAlive'] = { unit: 's', value: payload[2] * 20 };
                appContent['transmissionPeriodData'] = { unit: 's', value: payload[3] * 20 };
            }
            else {
                // PRODUCTION mode => period = value * 10min
                appContent['transmissionPeriodKeepAlive'] = { unit: 'm', value: payload[2] * 10 };
                appContent['transmissionPeriodData'] = { unit: 'm', value: payload[3] * 10 };
            }
            let debounce = this.getDebounceText(payload[5] >> 4);
            ch1['id'] = (payload[4] & 0xf0) >> 4;
            ch1['type'] = this.getSensorTypeText(payload[4] & 0x0f);
            if (payload[4] & 0x0f) {
                ch1['threshold'] = this.getThresholdTriggeringText(payload[5] & 0x03);
                ch1['externalTrigger'] = {
                    type: this.getThresholdTriggeringText((payload[5] >> 2) & 0x03),
                    debounceDuration: { unit: debounce[1], value: debounce[0] },
                };
            }
            debounce = this.getDebounceText(payload[7] >> 4);
            ch2['id'] = (payload[6] & 0xf0) >> 4;
            ch2['type'] = this.getSensorTypeText(payload[6] & 0x0f);
            if (payload[6] & 0x0f) {
                ch2['threshold'] = this.getThresholdTriggeringText(payload[7] & 0x03);
                ch2['externalTrigger'] = {
                    type: this.getThresholdTriggeringText((payload[7] >> 2) & 0x03),
                    debounceDuration: { unit: debounce[1], value: debounce[0] },
                };
            }
            appContent['channels'] = [ch1, ch2];
            // Product mode
            appContent['productMode'] = codec.PlateformCommonUtils.getProductModeText(payload[8]);
            return appContent;
        }
        /**
         * Get Sensor type text
         * @param value value
         */
        getSensorTypeText(value) {
            switch (value) {
                case 0:
                    return 'deactivated';
                case 1:
                    return '0-10V';
                case 2:
                    return '4-20mA';
                default:
                    return '';
            }
        }
        /**
         * Get Threshold Triggering text
         * @param value value
         */
        getThresholdTriggeringText(value) {
            switch (value) {
                case 0:
                    return 'none';
                case 1:
                    return 'low';
                case 2:
                    return 'high';
                case 3:
                    return 'both';
                default:
                    return '';
            }
        }
        /**
         * Get Waiting Period Duration text
         * @param value value
         */
        getDebounceText(value) {
            switch (value) {
                case 0:
                    return [0, 's'];
                case 1:
                    return [10, 'ms'];
                case 2:
                    return [20, 'ms'];
                case 3:
                    return [50, 'ms'];
                case 4:
                    return [100, 'ms'];
                case 5:
                    return [200, 'ms'];
                case 6:
                    return [500, 'ms'];
                case 7:
                    return [1, 's'];
                case 8:
                    return [2, 's'];
                case 9:
                    return [5, 's'];
                case 10:
                    return [10, 's'];
                case 11:
                    return [20, 's'];
                case 12:
                    return [40, 's'];
                case 13:
                    return [60, 's'];
                case 14:
                    return [5, 'm'];
                default:
                    return [0, 's'];
            }
        }
    }
    codec.Analog0x10Parser = Analog0x10Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Analog 0x11 (configuration) frame parser
     */
    class Analog0x11Parser {
        deviceType = 'analog';
        frameCode = 0x11;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x11 Analog configuration' };
            // channel A high threshold configuration
            appContent['threshold'] = {
                name: 'channel A',
                unit: '\u00B5' + 'V or 10 nA',
                high: {
                    value: payload.readUInt32BE(1) & 0x00ffffff,
                    hysteresis: payload.readUInt32BE(4) & 0x00ffffff,
                },
            };
            return appContent;
        }
    }
    codec.Analog0x11Parser = Analog0x11Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Analog 0x12 (configuration) frame parser
     */
    class Analog0x12Parser {
        deviceType = 'analog';
        frameCode = 0x12;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x12 Analog configuration' };
            // channel A high threshold configuration
            appContent['threshold'] = {
                name: 'channel A',
                unit: '\u00B5' + 'V or 10 nA',
                low: {
                    value: payload.readUInt32BE(1) & 0x00ffffff,
                    hysteresis: payload.readUInt32BE(4) & 0x00ffffff,
                },
            };
            return appContent;
        }
    }
    codec.Analog0x12Parser = Analog0x12Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Analog 0x13 (configuration) frame parser
     */
    class Analog0x13Parser {
        deviceType = 'analog';
        frameCode = 0x13;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x13 Analog configuration' };
            // channel B high threshold configuration
            appContent['threshold'] = {
                name: 'channel B',
                unit: '\u00B5' + 'V or 10 nA',
                high: {
                    value: payload.readUInt32BE(1) & 0x00ffffff,
                    hysteresis: payload.readUInt32BE(4) & 0x00ffffff,
                },
            };
            return appContent;
        }
    }
    codec.Analog0x13Parser = Analog0x13Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Analog 0x14 (configuration) frame parser
     */
    class Analog0x14Parser {
        deviceType = 'analog';
        frameCode = 0x14;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x14 Analog configuration' };
            // channel B high threshold configuration
            appContent['threshold'] = {
                name: 'channel B',
                unit: '\u00B5' + 'V or 10 nA',
                low: {
                    value: payload.readUInt32BE(1) & 0x00ffffff,
                    hysteresis: payload.readUInt32BE(4) & 0x00ffffff,
                },
            };
            return appContent;
        }
    }
    codec.Analog0x14Parser = Analog0x14Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Analog 0x30 (keep alive) frame parser
     */
    class Analog0x30Parser {
        deviceType = 'analog';
        frameCode = 0x30;
        parser = new codec.Analog0x42Parser();
        parseFrame(payload, configuration, network) {
            const appContent = this.parser.parseFrame(payload, configuration, network);
            appContent['type'] = '0x30 Analog keep alive';
            return appContent;
        }
    }
    codec.Analog0x30Parser = Analog0x30Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Analog 0x42 (data) frame parser
     */
    class Analog0x42Parser {
        deviceType = 'analog';
        frameCode = 0x42;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x42 Analog data' };
            const ch1 = { name: 'channel A' };
            const ch2 = { name: 'channel B' };
            // channel A
            let type = payload[2] & 0x0f;
            let rawValue = payload.readUInt32BE(2) & 0x00ffffff;
            if (type === 1) {
                ch1['unit'] = 'V';
                // convert µV into V (with 3 fraction digits)
                ch1['value'] = parseFloat((rawValue / (1000 * 1000)).toFixed(3));
            }
            else if (type === 2) {
                ch1['unit'] = 'mA';
                // convert 10nA into mA (with 3 fraction digits)
                ch1['value'] = parseFloat((rawValue / (100 * 1000)).toFixed(3));
            }
            else {
                ch1['state'] = 'deactivated';
            }
            // channel A
            type = payload[6] & 0x0f;
            rawValue = payload.readUInt32BE(6) & 0x00ffffff;
            if (type === 1) {
                ch2['unit'] = 'V';
                // convert µV into V (with 3 fraction digits)
                ch2['value'] = parseFloat((rawValue / (1000 * 1000)).toFixed(3));
            }
            else if (type === 2) {
                ch2['unit'] = 'mA';
                // convert 10nA into mA (with 3 fraction digits)
                ch2['value'] = parseFloat((rawValue / (100 * 1000)).toFixed(3));
            }
            else {
                ch2['state'] = 'deactivated';
            }
            appContent['channels'] = [ch1, ch2];
            return appContent;
        }
    }
    codec.Analog0x42Parser = Analog0x42Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Analog status byte parser
     */
    class AnalogStatusByteParser {
        deviceType = 'analog';
        frameCode = 0;
        parseFrame(payload, configuration, network) {
            let statusContent = {};
            const parser = new codec.GenericStatusByteParser();
            statusContent = parser.parseFrame(payload, configuration);
            // Status byte, applicative flags
            statusContent['alarmChannelA'] = Boolean(payload[1] & 0x08);
            statusContent['alarmChannelB'] = Boolean(payload[1] & 0x10);
            return { status: statusContent };
        }
    }
    codec.AnalogStatusByteParser = AnalogStatusByteParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Analog V2 0x10 (configuration) frame parser
     */
    class Analog20x10Parser {
        deviceType = 'analog2';
        frameCode = 0x10;
        parseFrame(payload, configuration, network) {
            // register 300: Emission period of the life frame X 10s
            // register 301: Issue period, value betwenn 0 and 65535, 0: disabling periodic transmission
            // register 320: value between 1 and 65535
            // register 321: value between 0 and 65535, 0: no scanning, X2s
            // reading_frequency = S321 * S320
            // sending_frequency = S321 * S320 * S301
            const appContent = { type: '0x10 Analog V2 configuration' };
            (appContent['transmissionPeriodKeepAlive'] = { unit: 's', value: payload.readUInt16BE(2) * 10 }),
                (appContent['numberOfHistorizationBeforeSending'] = payload.readUInt16BE(4)),
                (appContent['numberOfSamplingBeforeHistorization'] = payload.readUInt16BE(6)),
                (appContent['samplingPeriod'] = { unit: 's', value: payload.readUInt16BE(8) * 2 }),
                (appContent['redundantSamples'] = payload.readUInt8(10)),
                (appContent['calculatedPeriodRecording'] = {
                    unit: 's',
                    value: payload.readUInt16BE(8) * payload.readUInt16BE(6) * 2,
                }),
                (appContent['calculatedSendingPeriod'] = {
                    unit: 's',
                    value: payload.readUInt16BE(8) * payload.readUInt16BE(6) * payload.readUInt16BE(4) * 2,
                });
            return appContent;
        }
    }
    codec.Analog20x10Parser = Analog20x10Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Analog 0x30 (keep alive) frame parser
     */
    class Analog20x30Parser {
        deviceType = 'analog2';
        frameCode = 0x30;
        parser = new codec.Analog20x42Parser();
        parseFrame(payload, configuration, network) {
            const appContent = this.parser.parseFrame(payload, configuration, network);
            appContent['type'] = '0x30 Analog V2 keep alive';
            return appContent;
        }
    }
    codec.Analog20x30Parser = Analog20x30Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Analog V2 0x38 (keep alive) frame parser
     */
    class Analog20x38Parser {
        deviceType = 'analog2';
        frameCode = 0x38;
        parser = new codec.Analog20x71Parser();
        parseFrame(payload, configuration, network) {
            const appContent = this.parser.parseFrame(payload, configuration, network);
            appContent['type'] = '0x38 Analog V2 keep alive';
            return appContent;
        }
    }
    codec.Analog20x38Parser = Analog20x38Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Analog 0x42 (data) frame parser
     */
    class Analog20x42Parser {
        deviceType = 'analog2';
        frameCode = 0x42;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x42 Analog V2 data' };
            const ch1 = { name: 'channel A' };
            const ch2 = { name: 'channel B' };
            // channel A
            let type = payload[2] & 0x0f;
            let rawValue = payload.readUInt32BE(2) & 0x00ffffff;
            if (type === 1) {
                ch1['unit'] = 'V';
                // convert µV into V (with 3 fraction digits)
                ch1['value'] = parseFloat((rawValue / (1000 * 1000)).toFixed(3));
            }
            else if (type === 2) {
                ch1['unit'] = 'mA';
                // convert 10nA into mA (with 3 fraction digits)
                ch1['value'] = parseFloat((rawValue / (100 * 1000)).toFixed(3));
            }
            else {
                ch1['state'] = 'deactivated';
            }
            // channel A
            type = payload[6] & 0x0f;
            rawValue = payload.readUInt32BE(6) & 0x00ffffff;
            if (type === 1) {
                ch2['unit'] = 'V';
                // convert µV into V (with 3 fraction digits)
                ch2['value'] = parseFloat((rawValue / (1000 * 1000)).toFixed(3));
            }
            else if (type === 2) {
                ch2['unit'] = 'mA';
                // convert 10nA into mA (with 3 fraction digits)
                ch2['value'] = parseFloat((rawValue / (100 * 1000)).toFixed(3));
            }
            else {
                ch2['state'] = 'deactivated';
            }
            appContent['channels'] = [ch1, ch2];
            return appContent;
        }
    }
    codec.Analog20x42Parser = Analog20x42Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Analog V2 0x71 (data) frame parser
     */
    class Analog20x71Parser {
        deviceType = 'analog2';
        frameCode = 0x71;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x71 Analog V2 periodic data' };
            let rawValue;
            const channels = [];
            const ch1 = [], ch2 = [];
            const nbSensors = (payload[2] & 0x01 ? 1 : 0) + (payload[2] & 0x04 ? 1 : 0);
            const payloadLength = payload[1] & 0x04 ? payload.length - 4 : payload.length;
            // Loop through historic data [t=0, t-1, t-2,...]
            // we subtract 4 bytes from the total length of the frame to deduce the timestamp
            for (let offset = 3; offset < payloadLength; offset += 2 * nbSensors) {
                rawValue = payload.readUInt16BE(offset);
                ch1.push(rawValue / 1000);
                if (nbSensors === 2) {
                    rawValue = payload.readUInt16BE(offset + 2);
                    ch2.push(rawValue / 1000);
                }
            }
            if (payload[1] & 0x04) {
                // retrieval of the frame date timestamp value, then conversion to epoch 2013 (+1356998400), then in second
                const myDate = new Date((payload.readUInt32BE(payload.length - 4) + 1356998400) * 1000);
                // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
                appContent['timestamp'] = myDate.toJSON().replace('Z', '');
            }
            appContent['decodingInfo'] = 'values: [t=0, t-1, t-2, ...]';
            //Only channel B is active
            if (nbSensors == 1 && payload[2] & 0x04) {
                channels['push']({ name: 'channel B', unit: payload[2] & 0x08 ? 'mA' : 'V', values: ch1 });
            }
            else {
                channels['push']({ name: 'channel A', unit: payload[2] & 0x02 ? 'mA' : 'V', values: ch1 });
            }
            if (nbSensors === 2) {
                channels['push']({ name: 'channel B', unit: payload[2] & 0x08 ? 'mA' : 'V', values: ch2 });
            }
            appContent['channels'] = channels;
            return appContent;
        }
    }
    codec.Analog20x71Parser = Analog20x71Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Analog V2 0x72 (alarm) frame parser
     */
    class Analog20x72Parser {
        deviceType = 'analog2';
        frameCode = 0x72;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x72 Analog V2 alarm' };
            const alarms = [];
            const nbSensors = (payload[2] & 0x01 ? 1 : 0) + (payload[2] & 0x04 ? 1 : 0);
            //Only channel B is active
            if (nbSensors == 1 && payload[2] & 0x04) {
                alarms['push']({
                    name: 'channel B',
                    alarmStatus: this.getAlarmStatusText(payload.readUInt8(3)),
                    unit: payload[2] & 0x08 ? 'mA' : 'V',
                    value: payload.readUInt16BE(4) / 1000,
                });
            }
            else {
                alarms['push']({
                    name: 'channel A',
                    alarmStatus: this.getAlarmStatusText(payload.readUInt8(3)),
                    unit: payload[2] & 0x02 ? 'mA' : 'V',
                    value: payload.readUInt16BE(4) / 1000,
                });
            }
            if (nbSensors === 2) {
                alarms['push']({
                    name: 'channel B',
                    alarmStatus: this.getAlarmStatusText(payload.readUInt8(6)),
                    unit: payload[2] & 0x08 ? 'mA' : 'V',
                    value: payload.readUInt16BE(7) / 1000,
                });
            }
            appContent['alarms'] = alarms;
            if (payload[1] & 0x04) {
                // retrieval of the frame date timestamp value, then conversion to epoch 2013 (+1356998400), then in second
                const myDate = new Date((payload.readUInt32BE(payload.length - 4) + 1356998400) * 1000);
                // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
                appContent['timestamp'] = myDate.toJSON().replace('Z', '');
            }
            appContent['alarms'] = alarms;
            return appContent;
        }
        /**
         * Get Alarm status text
         * @param value value
         */
        getAlarmStatusText(value) {
            switch (value) {
                case 1:
                    return 'highThreshold';
                case 2:
                    return 'lowThreshold';
                case 3:
                    return 'inputEvent';
                default:
                    return 'none';
            }
        }
    }
    codec.Analog20x72Parser = Analog20x72Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Analog status byte parser
     */
    class Analog2StatusByteParser {
        deviceType = 'analog2';
        frameCode = 0;
        parseFrame(payload, configuration, network) {
            let statusContent = {};
            const parser = new codec.GenericStatusByteParser();
            statusContent = parser.parseFrame(payload, configuration);
            // frame 0x30 and 0x42 are sent only if backwards compatibility is active. In that case, handle status flag as for analog V1
            if (payload[0] == 0x30 || payload[0] == 0x42) {
                statusContent['alarmChannelA'] = Boolean(payload[1] & 0x08);
                statusContent['alarmChannelB'] = Boolean(payload[1] & 0x10);
            }
            else {
                statusContent['configurationInconsistency'] = Boolean(payload[1] & 0x08);
                statusContent['timestamp'] = Boolean(payload[1] & 0x04);
            }
            return { status: statusContent };
        }
    }
    codec.Analog2StatusByteParser = Analog2StatusByteParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Breath 0x10 (configuration) frame parser
     */
    class Breath0x10Parser {
        deviceType = 'breath';
        frameCode = 0x10;
        parseFrame(payload, configuration, network) {
            // register 300: Keep Alive frame TX 0: Disable or 1: Enable H24 frame
            // register 301: Issue period, value betwenn 0 and 65535, 0: disabling periodic transmission
            // register 320: value between 1 and 65535
            // register 321: value between 0 and 65535, 0: no scanning, X2s
            // register 323: value between 1 and 255 : Number of additional (redundant) samples per frame
            const appContent = { type: '0x10 Breath configuration' };
            (appContent['dailyFrameActivated'] = Boolean(payload.readUInt8(2) === 0 ? false : true)),
                (appContent['numberOfHistorizationBeforeSending'] = payload.readUInt16BE(3)),
                (appContent['historyPeriod'] = { unit: 's', value: payload.readUInt16BE(5) }),
                (appContent['alarmRepeatActivated'] = Boolean(payload.readUInt8(7) === 0 ? false : true)),
                (appContent['alarmRepeatPeriod'] = { unit: 's', value: payload.readUInt16BE(8) }),
                (appContent['redundantSamples'] = payload.readUInt8(10));
            return appContent;
        }
    }
    codec.Breath0x10Parser = Breath0x10Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Breath 0x30 Keep alive / daily frame parser
     */
    class Breath0x30Parser {
        deviceType = 'breath';
        frameCode = 0x30;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x30 Daily frame' };
            if (payload.length >= 11) {
                appContent['tvoc'] = {
                    min: { unit: 'µg/m3', value: payload.readUInt16BE(2) },
                    max: { unit: 'µg/m3', value: payload.readUInt16BE(4) },
                    average: { unit: 'µg/m3', value: payload.readUInt16BE(6) },
                    duration: { unit: 'min', value: payload.readUInt16BE(8) },
                };
                appContent['pm10'] = {
                    min: { unit: 'µg/m3', value: payload.readUInt16BE(10) },
                    max: { unit: 'µg/m3', value: payload.readUInt16BE(12) },
                    average: { unit: 'µg/m3', value: payload.readUInt16BE(14) },
                    duration: { unit: 'min', value: payload.readUInt16BE(16) },
                };
                appContent['pm25'] = {
                    min: { unit: 'µg/m3', value: payload.readUInt16BE(18) },
                    max: { unit: 'µg/m3', value: payload.readUInt16BE(20) },
                    average: { unit: 'µg/m3', value: payload.readUInt16BE(22) },
                    duration: { unit: 'min', value: payload.readUInt16BE(24) },
                };
                appContent['pm1'] = {
                    min: { unit: 'µg/m3', value: payload.readUInt16BE(26) },
                    max: { unit: 'µg/m3', value: payload.readUInt16BE(28) },
                    average: { unit: 'µg/m3', value: payload.readUInt16BE(30) },
                };
            }
            else {
                appContent['tvoc'] = { max: { unit: 'µg/m3', value: payload.readUInt16BE(2) } };
                appContent['pm10'] = { max: { unit: 'µg/m3', value: payload.readUInt16BE(4) } };
                appContent['pm25'] = { max: { unit: 'µg/m3', value: payload.readUInt16BE(6) } };
                appContent['pm1'] = { max: { unit: 'µg/m3', value: payload.readUInt16BE(8) } };
            }
            return appContent;
        }
    }
    codec.Breath0x30Parser = Breath0x30Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Breath 0X6D (data) frame parser
     */
    class Breath0x6dParser {
        deviceType = 'breath';
        frameCode = 0x6d;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x6d Breath periodic data' };
            let rawValue;
            const pm10 = [], pm25 = [], pm1 = [], tvoc = [];
            const payloadLength = payload.length;
            // Loop through historic data [t=0, t-1, t-2,...]
            for (let offset = 2; offset < payloadLength; offset += 8) {
                rawValue = payload.readUInt16BE(offset);
                tvoc.push(rawValue);
                rawValue = payload.readUInt16BE(offset + 2);
                pm10.push(rawValue);
                rawValue = payload.readUInt16BE(offset + 4);
                pm25.push(rawValue);
                rawValue = payload.readUInt16BE(offset + 6);
                pm1.push(rawValue);
            }
            appContent['decodingInfo'] = 'values: [t=0, t-1, t-2, ...]';
            appContent['tvoc'] = { unit: 'µg/m3', values: tvoc };
            appContent['pm10'] = { unit: 'µg/m3', values: pm10 };
            appContent['pm25'] = { unit: 'µg/m3', values: pm25 };
            appContent['pm1'] = { unit: 'µg/m3', values: pm1 };
            return appContent;
        }
    }
    codec.Breath0x6dParser = Breath0x6dParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Breath 0x6e (alarm) frame parser
     */
    class Breath0x6eParser {
        deviceType = 'breath';
        frameCode = 0x6e;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x6e Breath alarm' };
            appContent['tvoc'] = {
                alarmStatus: payload[2] & 0x01 ? 'active' : 'inactive',
                unit: 'µg/m3',
                value: payload.readUInt16BE(3),
            };
            appContent['pm10'] = {
                alarmStatus: payload[2] & 0x02 ? 'active' : 'inactive',
                unit: 'µg/m3',
                value: payload.readUInt16BE(5),
            };
            appContent['pm25'] = {
                alarmStatus: payload[2] & 0x04 ? 'active' : 'inactive',
                unit: 'µg/m3',
                value: payload.readUInt16BE(7),
            };
            appContent['pm1'] = {
                alarmStatus: payload[2] & 0x08 ? 'active' : 'inactive',
                unit: 'µg/m3',
                value: payload.readUInt16BE(9),
            };
            return appContent;
        }
    }
    codec.Breath0x6eParser = Breath0x6eParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Breath status byte parser
     */
    class BreathStatusByteParser {
        deviceType = 'breath';
        frameCode = 0;
        parseFrame(payload, configuration, network) {
            let statusContent = {};
            const parser = new codec.GenericStatusByteParser();
            statusContent = parser.parseFrame(payload, configuration);
            // Status byte, applicative flags
            statusContent['configurationInconsistency'] = Boolean(payload[1] & 0x08);
            statusContent['sensorError'] = Boolean(payload[1] & 0x16);
            return { status: statusContent };
        }
    }
    codec.BreathStatusByteParser = BreathStatusByteParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Comfort 0x10 (configuration) frame parser
     */
    class Comfort0x10Parser {
        deviceType = 'comfort';
        frameCode = 0x10;
        parseFrame(payload, configuration, network) {
            // register 300: Emission period of the life frame X 10s
            // register 301: Issue period, value betwenn 0 and 65535, 0: disabling periodic transmission
            // register 320: value between 1 and 65535
            // register 321: value between 0 and 65535, 0: no scanning, X2s
            // reading_frequency = S321 * S320
            // sending_frequency = S321 * S320 * S301
            const appContent = { type: '0x10 Comfort configuration' };
            (appContent['transmissionPeriodKeepAlive'] = { unit: 's', value: payload.readUInt16BE(2) * 10 }),
                (appContent['numberOfHistorizationBeforeSending'] = payload.readUInt16BE(4)),
                (appContent['numberOfSamplingBeforeHistorization'] = payload.readUInt16BE(6)),
                (appContent['samplingPeriod'] = { unit: 's', value: payload.readUInt16BE(8) * 2 }),
                (appContent['calculatedPeriodRecording'] = {
                    unit: 's',
                    value: payload.readUInt16BE(8) * payload.readUInt16BE(6) * 2,
                }),
                (appContent['calculatedSendingPeriod'] = {
                    unit: 's',
                    value: payload.readUInt16BE(8) * payload.readUInt16BE(6) * payload.readUInt16BE(4) * 2,
                });
            return appContent;
        }
    }
    codec.Comfort0x10Parser = Comfort0x10Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Comfort 0x4c (historic data) frame parser
     */
    class Comfort0x4cParser {
        deviceType = 'comfort';
        frameCode = 0x4c;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x4c Comfort data' };
            let rawValue;
            const temp = [], humidity = [];
            // Loop through historic data [t=0, t-1, t-2,...]
            for (let offset = 2; offset < payload.length; offset += 3) {
                rawValue = payload.readInt16BE(offset);
                temp.push(rawValue / 10);
                rawValue = payload.readUInt8(offset + 2);
                humidity.push(rawValue);
            }
            appContent['decodingInfo'] = 'values: [t=0, t-1, t-2, ...]';
            appContent['temperature'] = { unit: '\u00B0' + 'C', values: temp };
            appContent['humidity'] = { unit: '\u0025', values: humidity };
            return appContent;
        }
    }
    codec.Comfort0x4cParser = Comfort0x4cParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Comfort 0x4d (alarm) frame parser
     */
    class Comfort0x4dParser {
        deviceType = 'comfort';
        frameCode = 0x4d;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x4d Comfort alarm' };
            appContent['alarmTemperature'] = {
                alarmStatus: payload.readUInt8(2) >> 4 ? 'active' : 'inactive',
                temperature: { unit: '\u00B0' + 'C', value: payload.readInt16BE(3) / 10 },
            };
            appContent['alarmHumidity'] = {
                alarmStatus: payload.readUInt8(2) & 1 ? 'active' : 'inactive',
                humidity: { unit: '\u0025', value: payload.readUInt8(5) },
            };
            return appContent;
        }
    }
    codec.Comfort0x4dParser = Comfort0x4dParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Comfort CO2 0x10 (configuration) frame parser
     */
    class ComfortCo20x10Parser {
        deviceType = 'comfortCo2';
        frameCode = 0x10;
        parseFrame(payload, configuration, network) {
            // register 300: Keep Alive frame TX 0: Disable or 1: Enable H24 frame
            // register 301: Issue period, value betwenn 0 and 65535, 0: disabling periodic transmission
            // register 320: value between 1 and 65535
            // register 321: value between 0 and 65535, 0: no scanning, X2s
            // register 323: value between 1 and 255 : Number of additional (redundant) samples per frame
            // reading_frequency = S321 * S320
            // sending_frequency = S321 * S320 * S301
            const appContent = { type: '0x10 Comfort CO2 configuration' };
            (appContent['dailyFrameActivated'] = Boolean(payload.readUInt16BE(2) === 0 ? false : true)),
                (appContent['numberOfHistorizationBeforeSending'] = payload.readUInt16BE(4)),
                (appContent['numberOfSamplingBeforeHistorization'] = payload.readUInt16BE(6)),
                (appContent['samplingPeriod'] = { unit: 's', value: payload.readUInt16BE(8) * 2 }),
                (appContent['redundantSamples'] = payload.readUInt8(10)),
                (appContent['calculatedPeriodRecording'] = {
                    unit: 's',
                    value: payload.readUInt16BE(8) * payload.readUInt16BE(6) * 2,
                }),
                (appContent['calculatedSendingPeriod'] = {
                    unit: 's',
                    value: payload.readUInt16BE(8) * payload.readUInt16BE(6) * payload.readUInt16BE(4) * 2,
                });
            // Content depends on network
            if (payload.length >= 12) {
                appContent['blackOutDuration'] = { unit: 'h', value: payload.readUInt8(11) };
                appContent['blackOutStartTime'] = { unit: 'h', value: payload.readUInt8(12) };
            }
            return appContent;
        }
    }
    codec.ComfortCo20x10Parser = ComfortCo20x10Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Comfort CO2 0x30 Keep alive / daily frame parser
     */
    class ComfortCo20x30Parser {
        deviceType = 'comfortCo2';
        frameCode = 0x30;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x30 Comfort CO2 Daily frame' };
            if (payload[1] & 0x04) {
                // retrieval of the frame date timestamp value, then conversion to epoch 2013 (+1356998400), then in second
                const myDate = new Date((payload.readUInt32BE(19) + 1356998400) * 1000);
                // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
                appContent['timestamp'] = myDate.toJSON().replace('Z', '');
            }
            appContent['icone'] = payload.readUInt8(2);
            appContent['qaiRedDuration'] = { unit: 'min', value: payload.readUInt8(3) * 10 };
            appContent['temperatureMax'] = { unit: '\u00B0' + 'C', value: payload.readInt16BE(4) / 10 };
            appContent['co2Max'] = { unit: 'ppm', value: payload.readUInt16BE(6) };
            appContent['humidityMax'] = { unit: '%', value: payload.readUInt8(8) };
            appContent['temperatureMin'] = { unit: '\u00B0' + 'C', value: payload.readInt16BE(9) / 10 };
            // Content depends on network
            switch (payload.length) {
                case 11:
                    break;
                case 19:
                case 23:
                    appContent['co2Min'] = { unit: 'ppm', value: payload.readUInt16BE(11) };
                    appContent['humidityMin'] = { unit: '%', value: payload.readUInt8(13) };
                    appContent['temperatureAverage'] = { unit: '\u00B0' + 'C', value: payload.readInt16BE(14) / 10 };
                    appContent['co2Average'] = { unit: 'ppm', value: payload.readUInt16BE(16) };
                    appContent['humidityAverage'] = { unit: '%', value: payload.readUInt8(18) };
                    break;
                default:
                    appContent.partialDecoding = codec.PartialDecodingReason.MISSING_NETWORK;
                    break;
            }
            return appContent;
        }
    }
    codec.ComfortCo20x30Parser = ComfortCo20x30Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Comfort CO2 0x6a (historic data) frame parser
     */
    class ComfortCo20x6aParser {
        deviceType = 'comfortCo2';
        frameCode = 0x6a;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x6a Comfort CO2 data' };
            const payloadLength = payload[1] & 0x04 ? payload.length - 4 : payload.length;
            if (payload[1] & 0x04) {
                // retrieval of the frame date timestamp value, then conversion to epoch 2013 (+1356998400), then in second
                const myDate = new Date((payload.readUInt32BE(payloadLength) + 1356998400) * 1000);
                // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
                appContent['timestamp'] = myDate.toJSON().replace('Z', '');
            }
            let rawValue;
            const temp = [], humidity = [], CO2 = [];
            // Loop through historic data [t=0, t-1, t-2,...]
            for (let offset = 2; offset < payloadLength; offset += 5) {
                rawValue = payload.readInt16BE(offset);
                temp.push(rawValue / 10);
                rawValue = payload.readUInt8(offset + 2);
                humidity.push(rawValue);
                rawValue = payload.readUInt16BE(offset + 3);
                CO2.push(rawValue);
            }
            appContent['decodingInfo'] = 'values: [t=0, t-1, t-2, ...]';
            appContent['temperature'] = { unit: '\u00B0' + 'C', values: temp };
            appContent['humidity'] = { unit: '%', values: humidity };
            appContent['co2'] = { unit: 'ppm', values: CO2 };
            return appContent;
        }
    }
    codec.ComfortCo20x6aParser = ComfortCo20x6aParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Comfort CO2 0x6b (alarm) frame parser
     */
    class ComfortCo20x6bParser {
        deviceType = 'comfortCo2';
        frameCode = 0x6b;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x6b Comfort CO2 alarm' };
            const payloadLength = payload[1] & 0x04 ? payload.length - 4 : payload.length;
            if (payload[1] & 0x04) {
                // retrieval of the frame date timestamp value, then conversion to epoch 2013 (+1356998400), then in second
                const myDate = new Date((payload.readUInt32BE(payloadLength) + 1356998400) * 1000);
                // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
                appContent['timestamp'] = myDate.toJSON().replace('Z', '');
            }
            appContent['alarmTemperature'] = {
                alarmStatus: payload[2] & 0x10 ? 'active' : 'inactive',
                temperature: { unit: '\u00B0' + 'C', value: payload.readInt16BE(3) / 10 },
            };
            appContent['alarmHumidity'] = {
                alarmStatus: payload[2] & 0x01 ? 'active' : 'inactive',
                humidity: { unit: '%', value: payload.readUInt8(5) },
            };
            appContent['alarmCo2'] = {
                alarmStatus: payload[2] & 0x20 ? 'active' : 'inactive',
                co2: { unit: 'ppm', value: payload.readInt16BE(6) },
            };
            return appContent;
        }
    }
    codec.ComfortCo20x6bParser = ComfortCo20x6bParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Comfort CO2 status byte parser
     */
    class ComfortCo2StatusByteParser {
        deviceType = 'comfortCo2';
        frameCode = 0;
        parseFrame(payload, configuration, network) {
            let statusContent = {};
            const parser = new codec.GenericStatusByteParser();
            statusContent = parser.parseFrame(payload, configuration);
            // Status byte, applicative flags
            statusContent['configurationInconsistency'] = Boolean(payload[1] & 0x08);
            statusContent['timestamp'] = Boolean(payload[1] & 0x04);
            return { status: statusContent };
        }
    }
    codec.ComfortCo2StatusByteParser = ComfortCo2StatusByteParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Comfort Serenity 0x10 (configuration) frame parser
     */
    class ComfortSerenity0x10Parser {
        deviceType = 'comfortSerenity';
        frameCode = 0x10;
        parseFrame(payload, configuration, network) {
            // register 300: Keep Alive frame TX 0: Disable or 1: Enable H24 frame
            // register 301: Issue period, value betwenn 0 and 65535, 0: disabling periodic transmission
            // register 320: value between 1 and 65535
            // register 321: value between 0 and 65535, 0: no scanning, X2s
            // register 323: value between 1 and 255 : Number of additional (redundant) samples per frame
            // register 324: Black out duration (0: Disable), unit hour
            // register 325: Blackout start time (0h-23h)
            const appContent = { type: '0x10 Comfort Serenity configuration' };
            (appContent['dailyFrameActivated'] = Boolean(payload.readUInt16BE(2) === 0 ? false : true)),
                (appContent['numberOfHistorizationBeforeSending'] = payload.readUInt16BE(4)),
                (appContent['numberOfSamplingBeforeHistorization'] = payload.readUInt16BE(6)),
                (appContent['samplingPeriod'] = { unit: 's', value: payload.readUInt16BE(8) * 2 }),
                (appContent['redundantSamples'] = payload.readUInt8(10)),
                (appContent['calculatedPeriodRecording'] = {
                    unit: 's',
                    value: payload.readUInt16BE(8) * payload.readUInt16BE(6) * 2,
                }),
                (appContent['calculatedSendingPeriod'] = {
                    unit: 's',
                    value: payload.readUInt16BE(8) * payload.readUInt16BE(6) * payload.readUInt16BE(4) * 2,
                });
            // Content depends on network
            if (payload.length >= 12) {
                appContent['blackOutDuration'] = { unit: 'h', value: payload.readUInt8(11) };
                appContent['blackOutStartTime'] = { unit: 'h', value: payload.readUInt8(12) };
            }
            return appContent;
        }
    }
    codec.ComfortSerenity0x10Parser = ComfortSerenity0x10Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Comfort Serenity 0x30 Keep alive / daily frame parser
     */
    class ComfortSerenity0x30Parser {
        deviceType = 'comfortSerenity';
        frameCode = 0x30;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x30 Comfort Serenity Daily frame' };
            if (payload[1] & 0x04) {
                // retrieval of the frame date timestamp value, then conversion to epoch 2013 (+1356998400), then in second
                const myDate = new Date((payload.readUInt32BE(19) + 1356998400) * 1000);
                // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
                appContent['timestamp'] = myDate.toJSON().replace('Z', '');
            }
            appContent['icone'] = payload.readUInt8(2);
            appContent['qaiRedDuration'] = { unit: 'min', value: payload.readUInt8(3) * 10 };
            appContent['temperatureMax'] = { unit: '\u00B0' + 'C', value: payload.readInt16BE(4) / 10 };
            appContent['co2Max'] = { unit: 'ppm', value: payload.readUInt16BE(6) };
            appContent['humidityMax'] = { unit: '%', value: payload.readUInt8(8) };
            appContent['temperatureMin'] = { unit: '\u00B0' + 'C', value: payload.readInt16BE(9) / 10 };
            // Content depends on network
            switch (payload.length) {
                case 13:
                    break;
                case 19:
                case 23:
                    appContent['co2Min'] = { unit: 'ppm', value: payload.readUInt16BE(11) };
                    appContent['humidityMin'] = { unit: '%', value: payload.readUInt8(13) };
                    appContent['temperatureAverage'] = { unit: '\u00B0' + 'C', value: payload.readInt16BE(14) / 10 };
                    appContent['co2Average'] = { unit: 'ppm', value: payload.readUInt16BE(16) };
                    appContent['humidityAverage'] = { unit: '%', value: payload.readUInt8(18) };
                    break;
                default:
                    appContent.partialDecoding = codec.PartialDecodingReason.MISSING_NETWORK;
                    break;
            }
            return appContent;
        }
    }
    codec.ComfortSerenity0x30Parser = ComfortSerenity0x30Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Comfort Serenity 0x31 daily frame parser
     */
    class ComfortSerenity0x31Parser {
        deviceType = 'comfortSerenity';
        frameCode = 0x31;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x31 Comfort Serenity Get Register' };
            const payloadLength = payload[1] & 0x04 ? payload.length - 4 : payload.length;
            if (payload[1] & 0x04) {
                // retrieval of the frame date timestamp value, then conversion to epoch 2013 (+1356998400), then in second
                const myDate = new Date((payload.readUInt32BE(payloadLength) + 1356998400) * 1000);
                // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
                appContent['timestamp'] = myDate.toJSON().replace('Z', '');
            }
            appContent['value1'] = payload.readUInt16BE(2);
            appContent['value2'] = payload.readUInt8(4);
            appContent['value3'] = payload.readUInt32BE(5);
            return appContent;
        }
    }
    codec.ComfortSerenity0x31Parser = ComfortSerenity0x31Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Comfort Serenity 0x38 daily frame parser
     */
    class ComfortSerenity0x38Parser {
        deviceType = 'comfortSerenity';
        frameCode = 0x38;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x38 Comfort Serenity Daily frame' };
            if (payload[1] & 0x04) {
                // retrieval of the frame date timestamp value, then conversion to epoch 2013 (+1356998400), then in second
                const myDate = new Date((payload.readUInt32BE(25) + 1356998400) * 1000);
                // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
                appContent['timestamp'] = myDate.toJSON().replace('Z', '');
            }
            appContent['icone'] = payload.readUInt8(2);
            appContent['qaiRedDuration'] = { unit: 'min', value: payload.readUInt8(3) * 10 };
            appContent['temperatureMax'] = { unit: '\u00B0' + 'C', value: payload.readInt16BE(4) / 10 };
            appContent['co2Max'] = { unit: 'ppm', value: payload.readUInt16BE(6) };
            appContent['humidityMax'] = { unit: '%', value: payload.readUInt8(8) };
            appContent['vocMax'] = { unit: 'index value', value: payload.readUInt16BE(9) };
            // Content depends on network
            switch (payload.length) {
                case 11:
                    break;
                case 25:
                case 29:
                    appContent['temperatureMin'] = { unit: '\u00B0' + 'C', value: payload.readInt16BE(11) / 10 };
                    appContent['co2Min'] = { unit: 'ppm', value: payload.readUInt16BE(13) };
                    appContent['humidityMin'] = { unit: '%', value: payload.readUInt8(15) };
                    appContent['vocMin'] = { unit: 'index value', value: payload.readUInt16BE(16) };
                    appContent['temperatureAverage'] = { unit: '\u00B0' + 'C', value: payload.readInt16BE(18) / 10 };
                    appContent['co2Average'] = { unit: 'ppm', value: payload.readUInt16BE(20) };
                    appContent['humidityAverage'] = { unit: '%', value: payload.readUInt8(22) };
                    appContent['vocAverage'] = { unit: 'index value', value: payload.readUInt16BE(23) };
                    break;
                default:
                    appContent.partialDecoding = codec.PartialDecodingReason.MISSING_NETWORK;
                    break;
            }
            return appContent;
        }
    }
    codec.ComfortSerenity0x38Parser = ComfortSerenity0x38Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Comfort Serenity 0x6a (historic data) frame parser
     */
    class ComfortSerenity0x6aParser {
        deviceType = 'comfortSerenity';
        frameCode = 0x6a;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x6a Comfort Serenity data' };
            const payloadLength = payload[1] & 0x04 ? payload.length - 4 : payload.length;
            if (payload[1] & 0x04) {
                // retrieval of the frame date timestamp value, then conversion to epoch 2013 (+1356998400), then in second
                const myDate = new Date((payload.readUInt32BE(payloadLength) + 1356998400) * 1000);
                // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
                appContent['timestamp'] = myDate.toJSON().replace('Z', '');
            }
            let rawValue;
            const temp = [], humidity = [], CO2 = [];
            // Loop through historic data [t=0, t-1, t-2,...]
            for (let offset = 2; offset < payloadLength; offset += 5) {
                rawValue = payload.readInt16BE(offset);
                temp.push(rawValue / 10);
                rawValue = payload.readUInt8(offset + 2);
                humidity.push(rawValue);
                rawValue = payload.readUInt16BE(offset + 3);
                CO2.push(rawValue);
            }
            appContent['decodingInfo'] = 'values: [t=0, t-1, t-2, ...]';
            appContent['temperature'] = { unit: '\u00B0' + 'C', values: temp };
            appContent['humidity'] = { unit: '%', values: humidity };
            appContent['co2'] = { unit: 'ppm', values: CO2 };
            return appContent;
        }
    }
    codec.ComfortSerenity0x6aParser = ComfortSerenity0x6aParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Comfort Serenity 0x6b (alarm) frame parser
     */
    class ComfortSerenity0x6bParser {
        deviceType = 'comfortSerenity';
        frameCode = 0x6b;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x6b Comfort Serenity alarm' };
            const payloadLength = payload[1] & 0x04 ? payload.length - 4 : payload.length;
            if (payload[1] & 0x04) {
                // retrieval of the frame date timestamp value, then conversion to epoch 2013 (+1356998400), then in second
                const myDate = new Date((payload.readUInt32BE(payloadLength) + 1356998400) * 1000);
                // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
                appContent['timestamp'] = myDate.toJSON().replace('Z', '');
            }
            appContent['alarmTemperature'] = {
                alarmStatus: payload[2] & 0x10 ? 'active' : 'inactive',
                temperature: { unit: '\u00B0' + 'C', value: payload.readInt16BE(3) / 10 },
            };
            appContent['alarmHumidity'] = {
                alarmStatus: payload[2] & 0x01 ? 'active' : 'inactive',
                humidity: { unit: '%', value: payload.readUInt8(5) },
            };
            appContent['alarmCo2'] = {
                alarmStatus: payload[2] & 0x20 ? 'active' : 'inactive',
                co2: { unit: 'ppm', value: payload.readInt16BE(6) },
            };
            return appContent;
        }
    }
    codec.ComfortSerenity0x6bParser = ComfortSerenity0x6bParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Comfort Serenity 0x6f (historic data) frame parser
     */
    class ComfortSerenity0x6fParser {
        deviceType = 'comfortSerenity';
        frameCode = 0x6f;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x6f Comfort Serenity data' };
            const payloadLength = payload[1] & 0x04 ? payload.length - 4 : payload.length;
            if (payload[1] & 0x04) {
                // retrieval of the frame date timestamp value, then conversion to epoch 2013 (+1356998400), then in second
                const myDate = new Date((payload.readUInt32BE(payloadLength) + 1356998400) * 1000);
                // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
                appContent['timestamp'] = myDate.toJSON().replace('Z', '');
            }
            let rawValue;
            const temp = [], humidity = [], CO2 = [], COV = [];
            // Loop through historic data [t=0, t-1, t-2,...]
            for (let offset = 2; offset < payloadLength; offset += 7) {
                rawValue = payload.readInt16BE(offset);
                temp.push(rawValue / 10);
                rawValue = payload.readUInt8(offset + 2);
                humidity.push(rawValue);
                rawValue = payload.readUInt16BE(offset + 3);
                CO2.push(rawValue);
                rawValue = payload.readUInt16BE(offset + 5);
                COV.push(rawValue);
            }
            appContent['decodingInfo'] = 'values: [t=0, t-1, t-2, ...]';
            appContent['temperature'] = { unit: '\u00B0' + 'C', values: temp };
            appContent['humidity'] = { unit: '%', values: humidity };
            appContent['co2'] = { unit: 'ppm', values: CO2 };
            appContent['voc'] = { unit: 'index value', values: COV };
            return appContent;
        }
    }
    codec.ComfortSerenity0x6fParser = ComfortSerenity0x6fParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Comfort Serenity 0x70 (alarm) frame parser
     */
    class ComfortSerenity0x70Parser {
        deviceType = 'comfortSerenity';
        frameCode = 0x70;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x70 Comfort Serenity alarm' };
            const payloadLength = payload[1] & 0x04 ? payload.length - 4 : payload.length;
            if (payload[1] & 0x04) {
                // retrieval of the frame date timestamp value, then conversion to epoch 2013 (+1356998400), then in second
                const myDate = new Date((payload.readUInt32BE(payloadLength) + 1356998400) * 1000);
                // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
                appContent['timestamp'] = myDate.toJSON().replace('Z', '');
            }
            appContent['alarmTemperature'] = {
                alarmStatus: payload[2] & 0x10 ? 'active' : 'inactive',
                temperature: { unit: '\u00B0' + 'C', value: payload.readInt16BE(3) / 10 },
            };
            appContent['alarmHumidity'] = {
                alarmStatus: payload[2] & 0x01 ? 'active' : 'inactive',
                humidity: { unit: '%', value: payload.readUInt8(5) },
            };
            appContent['alarmCo2'] = {
                alarmStatus: payload[2] & 0x20 ? 'active' : 'inactive',
                co2: { unit: 'ppm', value: payload.readInt16BE(6) },
            };
            appContent['alarmVoc'] = {
                alarmStatus: payload[2] & 0x40 ? 'active' : 'inactive',
                voc: { unit: 'index value', value: payload.readInt16BE(8) },
            };
            return appContent;
        }
    }
    codec.ComfortSerenity0x70Parser = ComfortSerenity0x70Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Comfort Serenity status byte parser
     */
    class ComfortSerenityStatusByteParser {
        deviceType = 'comfortSerenity';
        frameCode = 0;
        parseFrame(payload, configuration, network) {
            let statusContent = {};
            const parser = new codec.GenericStatusByteParser();
            statusContent = parser.parseFrame(payload, configuration);
            // Status byte, applicative flags
            statusContent['configurationInconsistency'] = Boolean(payload[1] & 0x08);
            statusContent['timestamp'] = Boolean(payload[1] & 0x04);
            return { status: statusContent };
        }
    }
    codec.ComfortSerenityStatusByteParser = ComfortSerenityStatusByteParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Comfort 2 0x10 (configuration) frame parser
     */
    class Comfort20x10Parser {
        deviceType = 'comfort2';
        frameCode = 0x10;
        parseFrame(payload, configuration, network) {
            // register 300: Emission period of the life frame X 10s
            // register 301: Issue period, value betwenn 0 and 65535, 0: disabling periodic transmission
            // register 320: value between 1 and 65535
            // register 321: value between 0 and 65535, 0: no scanning, X2s
            // register 323: value between 1 and 255 : Number of additional (redundant) samples per frame
            // reading_frequency = S321 * S320
            // sending_frequency = S321 * S320 * S301
            const appContent = { type: '0x10 Comfort 2 configuration' };
            (appContent['transmissionPeriodKeepAlive'] = { unit: 's', value: payload.readUInt16BE(2) * 10 }),
                (appContent['numberOfHistorizationBeforeSending'] = payload.readUInt16BE(4)),
                (appContent['numberOfSamplingBeforeHistorization'] = payload.readUInt16BE(6)),
                (appContent['samplingPeriod'] = { unit: 's', value: payload.readUInt16BE(8) * 2 }),
                (appContent['redundantSamples'] = payload.readUInt8(10)),
                (appContent['calculatedPeriodRecording'] = {
                    unit: 's',
                    value: payload.readUInt16BE(8) * payload.readUInt16BE(6) * 2,
                }),
                (appContent['calculatedSendingPeriod'] = {
                    unit: 's',
                    value: payload.readUInt16BE(8) * payload.readUInt16BE(6) * payload.readUInt16BE(4) * 2,
                });
            return appContent;
        }
    }
    codec.Comfort20x10Parser = Comfort20x10Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Comfort 2 0x4c (historic data) frame parser
     */
    class Comfort20x4cParser {
        deviceType = 'comfort2';
        frameCode = 0x4c;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x4c Comfort 2 data' };
            const payloadLength = payload[1] & 0x04 ? payload.length - 4 : payload.length;
            if (payload[1] & 0x04) {
                // retrieval of the frame date timestamp value, then conversion to epoch 2013 (+1356998400), then in second
                const myDate = new Date((payload.readUInt32BE(payloadLength) + 1356998400) * 1000);
                // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
                appContent['timestamp'] = myDate.toJSON().replace('Z', '');
            }
            let rawValue;
            const temp = [], humidity = [];
            // Loop through historic data [t=0, t-1, t-2,...]
            for (let offset = 2; offset < payloadLength; offset += 3) {
                rawValue = payload.readInt16BE(offset);
                temp.push(rawValue / 10);
                rawValue = payload.readUInt8(offset + 2);
                humidity.push(rawValue);
            }
            appContent['decodingInfo'] = 'values: [t=0, t-1, t-2, ...]';
            appContent['temperature'] = { unit: '\u00B0' + 'C', values: temp };
            appContent['humidity'] = { unit: '\u0025', values: humidity };
            return appContent;
        }
    }
    codec.Comfort20x4cParser = Comfort20x4cParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Comfort 2 0x4d (alarm) frame parser
     */
    class Comfort20x4dParser {
        deviceType = 'comfort2';
        frameCode = 0x4d;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x4d Comfort 2 alarm' };
            if (payload[1] & 0x04) {
                // retrieval of the frame date timestamp value, then conversion to epoch 2013 (+1356998400), then in second
                const myDate = new Date((payload.readUInt32BE(6) + 1356998400) * 1000);
                // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
                appContent['timestamp'] = myDate.toJSON().replace('Z', '');
            }
            appContent['alarmTemperature'] = {
                alarmStatus: payload.readUInt8(2) >> 4 ? 'active' : 'inactive',
                temperature: { unit: '\u00B0' + 'C', value: payload.readInt16BE(3) / 10 },
            };
            appContent['alarmHumidity'] = {
                alarmStatus: payload.readUInt8(2) & 1 ? 'active' : 'inactive',
                humidity: { unit: '\u0025', value: payload.readUInt8(5) },
            };
            return appContent;
        }
    }
    codec.Comfort20x4dParser = Comfort20x4dParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Comfort 2 status byte parser
     */
    class Comfort2StatusByteParser {
        deviceType = 'comfort2';
        frameCode = 0;
        parseFrame(payload, configuration, network) {
            let statusContent = {};
            const parser = new codec.GenericStatusByteParser();
            statusContent = parser.parseFrame(payload, configuration);
            // Status byte, applicative flags
            statusContent['configurationInconsistency'] = Boolean(payload[1] & 0x08);
            statusContent['timestamp'] = Boolean(payload[1] & 0x04);
            return { status: statusContent };
        }
    }
    codec.Comfort2StatusByteParser = Comfort2StatusByteParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Delta P 0x10 (configuration) frame parser
     */
    class Deltap0x10Parser {
        deviceType = 'deltap';
        frameCode = 0x10;
        parseFrame(payload, configuration, network) {
            // register 300: Emission period of the life frame
            // register 301: Issue period, value between 0 and 65535, 0: disabling periodic transmission
            // register 320: value betwenn 1 and 65535
            // register 321: value betwenn 0 and 65535, 0: no scanning, X2s
            // reading_frequency = S321 * S320
            // sending_frequency = S321 * S320 * S301
            const appContent = { type: '0x10 Delta P configuration' };
            (appContent['transmissionPeriodKeepAlive'] = { unit: 's', value: payload.readUInt16BE(2) * 10 }),
                (appContent['numberOfHistorizationBeforeSending'] = payload.readUInt16BE(4)),
                (appContent['numberOfSamplingBeforeHistorization'] = payload.readUInt16BE(6)),
                (appContent['samplingPeriod'] = { unit: 's', value: payload.readUInt16BE(8) * 2 }),
                (appContent['calculatedPeriodRecording'] = {
                    unit: 's',
                    value: payload.readUInt16BE(8) * payload.readUInt16BE(6) * 2,
                }),
                (appContent['calculatedSendingPeriod'] = {
                    unit: 's',
                    value: payload.readUInt16BE(8) * payload.readUInt16BE(6) * payload.readUInt16BE(4) * 2,
                });
            return appContent;
        }
    }
    codec.Deltap0x10Parser = Deltap0x10Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Delta P 0x11 (0-10V configuration) frame parser
     */
    class Deltap0x11Parser {
        deviceType = 'deltap';
        frameCode = 0x11;
        parseFrame(payload, configuration, network) {
            // register 322: value between 1 and 65535
            // register 323: value between 0 and 65535, 0: no scanning, X2s
            // register 324: Issue period, value between 0 and 65535, 0: disabling periodic transmission
            // reading_frequency = S322 * S323
            // sending_frequency = S322 * S323 * S324
            const appContent = { type: '0x11 Delta P 0-10V configuration' };
            appContent['numberOfHistorizationBeforeSending'] = payload.readUInt16BE(6);
            appContent['numberOfSamplingBeforeHistorization'] = payload.readUInt16BE(2);
            appContent['samplingPeriod'] = { unit: 's', value: payload.readUInt16BE(4) * 2 };
            appContent['calculatedPeriodRecording'] = {
                unit: 's',
                value: payload.readUInt16BE(2) * payload.readUInt16BE(4) * 2,
            };
            appContent['calculatedSendingPeriod'] = {
                unit: 's',
                value: payload.readUInt16BE(2) * payload.readUInt16BE(4) * payload.readUInt16BE(6) * 2,
            };
            return appContent;
        }
    }
    codec.Deltap0x11Parser = Deltap0x11Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Generic 0x2f (downlink ACK) frame parser
     */
    class Deltap0x2fParser {
        deviceType = 'deltap';
        frameCode = 0x2f;
        parseFrame(payload, configuration) {
            const appContent = { type: '0x2f Delta P Downlink ack' };
            appContent['requestStatus'] = this.getRequestStatusText(payload[2]);
            return appContent;
        }
        /**
         * Get Type text
         * @param value value
         */
        getRequestStatusText(value) {
            switch (value) {
                case 1:
                    return 'success';
                case 2:
                    return 'errorGeneric';
                case 3:
                    return 'errorWrongState';
                case 4:
                    return 'errorInvalidRequest';
                default:
                    return 'errorOtherReason';
            }
        }
    }
    codec.Deltap0x2fParser = Deltap0x2fParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Delta P 0x53 (Delta P periodic) frame parser
     */
    class Deltap0x53Parser {
        deviceType = 'deltap';
        frameCode = 0x53;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x53 Delta P periodic data' };
            const pressures = [];
            // Loop through historic data [t=0, t-1, t-2,...]
            for (let offset = 2; offset < payload.length; offset += 2) {
                pressures.push(payload.readInt16BE(offset));
            }
            appContent['decodingInfo'] = 'values: [t=0, t-1, t-2, ...]';
            appContent['deltaPressure'] = { unit: 'pa', values: pressures };
            return appContent;
        }
    }
    codec.Deltap0x53Parser = Deltap0x53Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Delta P 0x54 (pressure alarm) frame parser
     */
    class Deltap0x54Parser {
        deviceType = 'deltap';
        frameCode = 0x54;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x54 Delta P alarm' };
            // Bit 0: alarm pressure state (0: inactive, 1: active)
            appContent['alarmStatus'] = payload.readUInt8(2) ? 'active' : 'inactive';
            // Pressure value
            appContent['deltaPressure'] = { unit: 'pa', value: payload.readInt16BE(3) };
            return appContent;
        }
    }
    codec.Deltap0x54Parser = Deltap0x54Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Delta P 0x55 (periodic 0-10 V) frame parser
     */
    class Deltap0x55Parser {
        deviceType = 'deltap';
        frameCode = 0x55;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x55 Delta P - periodic 0-10 V' };
            const voltages = [];
            // Loop through historic data [t=0, t-1, t-2,...]
            for (let offset = 2; offset < payload.length; offset += 2) {
                voltages.push(payload.readInt16BE(offset));
            }
            appContent['decodingInfo'] = 'values: [t=0, t-1, t-2, ...]';
            appContent['voltage'] = { unit: 'mV', values: voltages };
            return appContent;
        }
    }
    codec.Deltap0x55Parser = Deltap0x55Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Delta P 0x56 (alarm 0-10 V) frame parser
     */
    class Deltap0x56Parser {
        deviceType = 'deltap';
        frameCode = 0x56;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x56 Delta P - alarm 0-10 V' };
            // Bit 0: alarm state (0: inactive, 1:active)
            appContent['alarmStatus'] = payload.readUInt8(2) ? 'active' : 'inactive';
            // Voltage value (in mV)
            appContent['voltage'] = { unit: 'mV', value: payload.readInt16BE(3) };
            return appContent;
        }
    }
    codec.Deltap0x56Parser = Deltap0x56Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Dry Contacts 0x10 (configuration) frame parser
     */
    class Drycontacts0x10Parser {
        deviceType = 'drycontacts';
        frameCode = 0x10;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x10 Dry Contacts configuration' };
            // Product mode
            appContent['productMode'] = codec.PlateformCommonUtils.getProductModeText(payload[8]);
            if (payload[8] === 1) {
                appContent['keepAlivePeriod'] = { unit: 'm', value: payload.readUInt8(2) * 10 };
                appContent['transmitPeriod'] = { unit: 'm', value: payload.readUInt8(3) * 10 };
            }
            else {
                appContent['keepAlivePeriod'] = { unit: 's', value: payload.readUInt8(2) * 20 };
                appContent['transmitPeriod'] = { unit: 's', value: payload.readUInt8(3) * 20 };
            }
            // Channel x configuration
            // payload[y]<3:0> => type
            // payload[y]<7:4> => waiting period duration
            // Channel A configuration
            let debounce = this.getDebounceText(payload[4] >> 4);
            let type = this.getTypeText(payload[4] & 0x0f);
            if (type[0] === 'disabled') {
                appContent['channelA'] = { type: type[0] };
            }
            else {
                appContent['channelA'] = {
                    type: type[0],
                    edge: type[1],
                    debounceDuration: { unit: debounce[1], value: debounce[0] },
                };
            }
            // Channel B configuration
            debounce = this.getDebounceText(payload[5] >> 4);
            type = this.getTypeText(payload[5] & 0x0f);
            if (type[0] === 'disabled') {
                appContent['channelB'] = { type: type[0] };
            }
            else {
                appContent['channelB'] = {
                    type: type[0],
                    edge: type[1],
                    debounceDuration: { unit: debounce[1], value: debounce[0] },
                };
            }
            // Channel C configuration
            debounce = this.getDebounceText(payload[6] >> 4);
            type = this.getTypeText(payload[6] & 0x0f);
            if (type[0] === 'disabled') {
                appContent['channelC'] = { type: type[0] };
            }
            else {
                appContent['channelC'] = {
                    type: type[0],
                    edge: type[1],
                    debounceDuration: { unit: debounce[1], value: debounce[0] },
                };
            }
            // Channel D configuration
            debounce = this.getDebounceText(payload[7] >> 4);
            type = this.getTypeText(payload[7] & 0x0f);
            if (type[0] === 'disabled') {
                appContent['channelD'] = { type: type[0] };
            }
            else {
                appContent['channelD'] = {
                    type: type[0],
                    edge: type[1],
                    debounceDuration: { unit: debounce[1], value: debounce[0] },
                };
            }
            return appContent;
        }
        /**
         * Get Type text
         * @param value value
         */
        getTypeText(value) {
            switch (value) {
                case 0:
                    return ['disabled', ''];
                case 1:
                    return ['inputPeriodic', 'high'];
                case 2:
                    return ['inputPeriodic', 'low'];
                case 3:
                    return ['inputPeriodic', 'both'];
                case 4:
                    return ['inputEvent', 'high'];
                case 5:
                    return ['inputEvent', 'low'];
                case 6:
                    return ['inputEvent', 'both'];
                case 7:
                    return ['output', 'high'];
                case 8:
                    return ['output', 'low'];
                default:
                    return ['disabled', ''];
            }
        }
        /**
         * Get Waiting Period Duration text
         * @param value value
         */
        getDebounceText(value) {
            switch (value) {
                case 0:
                    return [0, 's'];
                case 1:
                    return [10, 'ms'];
                case 2:
                    return [20, 'ms'];
                case 3:
                    return [50, 'ms'];
                case 4:
                    return [100, 'ms'];
                case 5:
                    return [200, 'ms'];
                case 6:
                    return [500, 'ms'];
                case 7:
                    return [1, 's'];
                case 8:
                    return [2, 's'];
                case 9:
                    return [5, 's'];
                case 10:
                    return [10, 's'];
                case 11:
                    return [20, 's'];
                case 12:
                    return [40, 's'];
                case 13:
                    return [60, 's'];
                case 14:
                    return [5, 'm'];
                case 15:
                    return [10, 'm'];
                default:
                    return [0, 's'];
            }
        }
    }
    codec.Drycontacts0x10Parser = Drycontacts0x10Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Dry Contacts 0x40 (data) frame parser
     */
    class Drycontacts0x40Parser {
        deviceType = 'drycontacts';
        frameCode = 0x40;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x40 Dry Contacts data' };
            appContent['decodingInfo'] = 'true: ON/CLOSED, false: OFF/OPEN';
            appContent['channelA'] = {
                value: payload.readUInt16BE(2),
                currentState: Boolean(payload[10] & 0x01),
                previousFrameState: Boolean(payload[10] & 0x02),
            };
            appContent['channelB'] = {
                value: payload.readUInt16BE(4),
                currentState: Boolean(payload[10] & 0x04),
                previousFrameState: Boolean(payload[10] & 0x08),
            };
            appContent['channelC'] = {
                value: payload.readUInt16BE(6),
                currentState: Boolean(payload[10] & 0x10),
                previousFrameState: Boolean(payload[10] & 0x20),
            };
            appContent['channelD'] = {
                value: payload.readUInt16BE(8),
                currentState: Boolean(payload[10] & 0x40),
                previousFrameState: Boolean(payload[10] & 0x80),
            };
            return appContent;
        }
    }
    codec.Drycontacts0x40Parser = Drycontacts0x40Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * DRYCONTACTS status byte parser
     */
    class DrycontactsStatusByteParser {
        deviceType = 'drycontacts';
        frameCode = 0;
        parseFrame(payload, configuration) {
            let statusContent = {};
            const parser = new codec.GenericStatusByteParser();
            statusContent = parser.parseFrame(payload, configuration);
            return { status: statusContent };
        }
    }
    codec.DrycontactsStatusByteParser = DrycontactsStatusByteParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Dry Contacts 2 0x10 (configuration) frame parser
     */
    class Drycontacts20x10Parser {
        deviceType = 'drycontacts2';
        frameCode = 0x10;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x10 Dry Contacts 2 configuration' };
            appContent['keepAlivePeriod'] = { unit: 's', value: payload.readUInt16BE(2) * 10 };
            appContent['transmitPeriod'] = { unit: 's', value: payload.readUInt16BE(4) * 10 };
            // Channel x configuration
            // payload[y]<3:0> => type
            // payload[y]<7:4> => waiting period duration
            // Channel A configuration
            let debounce = this.getDebounceText(payload[6] >> 4);
            let type = this.getTypeText(payload[6] & 0x0f);
            if (type[0] === 'disabled' || type[0] === 'output') {
                appContent['channelA'] = { type: type[0] };
            }
            else {
                appContent['channelA'] = {
                    type: type[0],
                    edge: type[1],
                    debounceDuration: { unit: debounce[1], value: debounce[0] },
                };
            }
            // Channel B configuration
            debounce = this.getDebounceText(payload[7] >> 4);
            type = this.getTypeText(payload[7] & 0x0f);
            if (type[0] === 'disabled' || type[0] === 'output') {
                appContent['channelB'] = { type: type[0] };
            }
            else {
                appContent['channelB'] = {
                    type: type[0],
                    edge: type[1],
                    debounceDuration: { unit: debounce[1], value: debounce[0] },
                };
            }
            // Channel C configuration
            debounce = this.getDebounceText(payload[8] >> 4);
            type = this.getTypeText(payload[8] & 0x0f);
            if (type[0] === 'disabled' || type[0] === 'output') {
                appContent['channelC'] = { type: type[0] };
            }
            else {
                appContent['channelC'] = {
                    type: type[0],
                    edge: type[1],
                    debounceDuration: { unit: debounce[1], value: debounce[0] },
                };
            }
            // Channel D configuration
            debounce = this.getDebounceText(payload[9] >> 4);
            type = this.getTypeText(payload[9] & 0x0f);
            if (type[0] === 'disabled' || type[0] === 'output') {
                appContent['channelD'] = { type: type[0] };
            }
            else {
                appContent['channelD'] = {
                    type: type[0],
                    edge: type[1],
                    debounceDuration: { unit: debounce[1], value: debounce[0] },
                };
            }
            return appContent;
        }
        /**
         * Get Type text
         * @param value value
         */
        getTypeText(value) {
            switch (value) {
                case 0:
                    return ['disabled', ''];
                case 1:
                    return ['input', 'high'];
                case 2:
                    return ['input', 'low'];
                case 3:
                    return ['input', 'both'];
                case 4:
                    return ['output', ''];
                default:
                    return ['disabled', ''];
            }
        }
        /**
         * Get Waiting Period Duration text
         * @param value value
         */
        getDebounceText(value) {
            switch (value) {
                case 0:
                    return [0, 's'];
                case 1:
                    return [10, 'ms'];
                case 2:
                    return [20, 'ms'];
                case 3:
                    return [50, 'ms'];
                case 4:
                    return [100, 'ms'];
                case 5:
                    return [200, 'ms'];
                case 6:
                    return [500, 'ms'];
                case 7:
                    return [1, 's'];
                case 8:
                    return [2, 's'];
                case 9:
                    return [5, 's'];
                case 10:
                    return [10, 's'];
                case 11:
                    return [20, 's'];
                case 12:
                    return [40, 's'];
                case 13:
                    return [60, 's'];
                case 14:
                    return [5, 'm'];
                case 15:
                    return [10, 'm'];
                default:
                    return [0, 's'];
            }
        }
    }
    codec.Drycontacts20x10Parser = Drycontacts20x10Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Dry Contacts 0x30 (keep alive) frame parser
     */
    class Drycontacts20x30Parser {
        deviceType = 'drycontacts2';
        frameCode = 0x30;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x30 Dry Contacts 2 keep alive' };
            if (payload[1] & 0x04) {
                // retrieval of the frame date timestamp value, then conversion to epoch 2013 (+1356998400), then in second
                const myDate = new Date((payload.readUInt32BE(11) + 1356998400) * 1000);
                // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
                appContent['timestamp'] = myDate.toJSON().replace('Z', '');
            }
            appContent['channelA'] = { value: payload.readUInt16BE(2), state: Boolean(payload[10] & 0x01) };
            appContent['channelB'] = { value: payload.readUInt16BE(4), state: Boolean(payload[10] & 0x02) };
            appContent['channelC'] = { value: payload.readUInt16BE(6), state: Boolean(payload[10] & 0x04) };
            appContent['channelD'] = { value: payload.readUInt16BE(8), state: Boolean(payload[10] & 0x08) };
            return appContent;
        }
    }
    codec.Drycontacts20x30Parser = Drycontacts20x30Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Dry Contacts 0x40 (data) frame parser
     */
    class Drycontacts20x40Parser {
        deviceType = 'drycontacts2';
        frameCode = 0x40;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x40 Dry Contacts 2 data' };
            if (payload[1] & 0x04) {
                // retrieval of the frame date timestamp value, then conversion to epoch 2013 (+1356998400), then in second
                const myDate = new Date((payload.readUInt32BE(11) + 1356998400) * 1000);
                // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
                appContent['timestamp'] = myDate.toJSON().replace('Z', '');
            }
            appContent['decodingInfo'] = 'true: ON/CLOSED, false: OFF/OPEN';
            appContent['channelA'] = {
                value: payload.readUInt16BE(2),
                currentState: Boolean(payload[10] & 0x01),
                previousFrameState: Boolean(payload[10] & 0x02),
            };
            appContent['channelB'] = {
                value: payload.readUInt16BE(4),
                currentState: Boolean(payload[10] & 0x04),
                previousFrameState: Boolean(payload[10] & 0x08),
            };
            appContent['channelC'] = {
                value: payload.readUInt16BE(6),
                currentState: Boolean(payload[10] & 0x10),
                previousFrameState: Boolean(payload[10] & 0x20),
            };
            appContent['channelD'] = {
                value: payload.readUInt16BE(8),
                currentState: Boolean(payload[10] & 0x40),
                previousFrameState: Boolean(payload[10] & 0x80),
            };
            return appContent;
        }
    }
    codec.Drycontacts20x40Parser = Drycontacts20x40Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Dry Contacts 0x41 (duration alarm ) frame parser
     */
    class Drycontacts20x41Parser {
        deviceType = 'drycontacts2';
        frameCode = 0x41;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x41 Dry Contacts 2 duration alarm' };
            if (payload[1] & 0x04) {
                // retrieval of the frame date timestamp value, then conversion to epoch 2013 (+1356998400), then in second
                const myDate = new Date((payload.readUInt32BE(5) + 1356998400) * 1000);
                // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
                appContent['timestamp'] = myDate.toJSON().replace('Z', '');
            }
            appContent['channel'] = payload.readUInt8(2);
            appContent['durationThreshold'] = { unit: 'min', value: payload.readUInt16BE(3) };
            return appContent;
        }
    }
    codec.Drycontacts20x41Parser = Drycontacts20x41Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Dry Contacts 2 0x59 time counting data frame parser
     */
    class Drycontacts20x59Parser {
        deviceType = 'drycontacts2';
        frameCode = 0x59;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x59 Dry Contacts 2 time counting data' };
            // Concerns only Lora products
            if (payload[1] & 0x04) {
                // retrieval of the frame date timestamp value, then conversion to epoch 2013 (+1356998400), then in second
                const myDate = new Date((payload.readUInt32BE(payload.length - 4) + 1356998400) * 1000);
                // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
                appContent['timestamp'] = myDate.toJSON().replace('Z', '');
            }
            let offset = 3;
            if (payload[2] & 0x01) {
                appContent['channelATimeCounter'] = { unit: 's', value: payload.readUInt32BE(offset) };
                offset += 4;
            }
            if (payload[2] & 0x02) {
                appContent['channelBTimeCounter'] = { unit: 's', value: payload.readUInt32BE(offset) };
                offset += 4;
            }
            if (payload[2] & 0x04) {
                appContent['channelCTimeCounter'] = { unit: 's', value: payload.readUInt32BE(offset) };
                offset += 4;
            }
            if (payload[2] & 0x08) {
                appContent['channelDTimeCounter'] = { unit: 's', value: payload.readUInt32BE(offset) };
            }
            return appContent;
        }
    }
    codec.Drycontacts20x59Parser = Drycontacts20x59Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Temp 3 status byte parser
     */
    class Drycontacts2StatusByteParser {
        deviceType = 'drycontacts2';
        frameCode = 0;
        parseFrame(payload, configuration, network) {
            let statusContent = {};
            const parser = new codec.GenericStatusByteParser();
            statusContent = parser.parseFrame(payload, configuration);
            // Status byte, applicative flags
            statusContent['timestamp'] = Boolean(payload[1] & 0x04);
            return { status: statusContent };
        }
    }
    codec.Drycontacts2StatusByteParser = Drycontacts2StatusByteParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Smart Building 0x1f (TOR configuration) frame parser
     */
    class Generic0x1fParser {
        deviceType = 'motion|comfort|comfort2|comfortCo2|deltap|breath|comfortSerenity';
        frameCode = 0x1f;
        parseFrame(payload, configuration, network) {
            // register 380: Configuration digital input 1
            // register 381: Alarm threshold digital input 1
            // register 382: Configuration digital input 2
            // register 383: Alarm threshold digital input 2
            const appContent = { type: '0x1f digital input configuration' };
            const input1 = {};
            const input2 = {};
            input1['type'] = this.getTypeText(payload[2] & 0x0f);
            input1['debouncingPeriod'] = {
                unit: 'ms',
                value: this.getDebouncingPeriodText((payload[2] & 0xf0) >> 4),
            };
            input1['threshold'] = payload.readUInt16BE(3);
            input2['type'] = this.getTypeText(payload[5] & 0x0f);
            input2['debouncingPeriod'] = {
                unit: 'ms',
                value: this.getDebouncingPeriodText((payload[5] & 0xf0) >> 4),
            };
            input2['threshold'] = payload.readUInt16BE(6);
            appContent['digitalInput1'] = input1;
            appContent['digitalInput2'] = input2;
            return appContent;
        }
        /**
         * Get debounce duration text
         * @param value value
         */
        getDebouncingPeriodText(value) {
            switch (value) {
                case 0:
                    return 0;
                case 1:
                    return 10;
                case 2:
                    return 20;
                case 3:
                    return 500;
                case 4:
                    return 100;
                case 5:
                    return 200;
                case 6:
                    return 500;
                case 7:
                    return 1000;
                case 8:
                    return 2000;
                case 9:
                    return 5000;
                case 10:
                    return 10000;
                case 11:
                    return 20000;
                case 12:
                    return 40000;
                case 13:
                    return 60000;
                case 14:
                    return 300000;
                case 15:
                    return 600000;
                default:
                    return 0;
            }
        }
        /**
         * Get type text
         * @param value value
         */
        getTypeText(value) {
            switch (value) {
                case 0x0:
                    return 'deactivated';
                case 0x1:
                    return 'highEdge';
                case 0x2:
                    return 'lowEdge';
                case 0x3:
                    return 'bothEdges';
                default:
                    return '';
            }
        }
    }
    codec.Generic0x1fParser = Generic0x1fParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Generic 0x20 (configuration) frame parser
     */
    class Generic0x20Parser {
        deviceType = 'any';
        frameCode = 0x20;
        parseFrame(payload, configuration, network, deviceType) {
            const appContent = { type: '0x20 Configuration' };
            // Content depends on network
            switch (payload.length) {
                case 4:
                    appContent['loraAdr'] = Boolean(payload[2] & 0x01);
                    appContent['loraProvisioningMode'] = payload[3] === 0 ? 'ABP' : 'OTAA';
                    // TEMP3 , TEMP4 and PULSE3 use FW 2.0.0 . In that case byte 2 contains the entire S220 register
                    if (deviceType !== 'analog' && deviceType !== 'drycontacts' && deviceType !== 'pulse' && deviceType !== 'temp') {
                        appContent['loraDutycyle'] = payload[2] & 0x04 ? 'activated' : 'deactivated';
                        appContent['loraClassMode'] = payload[2] & 0x20 ? 'CLASS C' : 'CLASS A';
                    }
                    break;
                case 3:
                case 5:
                    appContent['sigfoxRetry'] = payload[2] & 0x03;
                    if (payload.length === 5) {
                        appContent['sigfoxDownlinkPeriod'] = { unit: 'm', value: payload.readInt16BE(3) };
                    }
                    break;
                default:
                    appContent.partialDecoding = codec.PartialDecodingReason.MISSING_NETWORK;
                    break;
            }
            return appContent;
        }
    }
    codec.Generic0x20Parser = Generic0x20Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Generic 0x2f (downlink ACK) frame parser
     */
    class Generic0x2fParser {
        deviceType = 'drycontacts|drycontacts2|temp4|comfortSerenity|modbus';
        frameCode = 0x2f;
        parseFrame(payload, configuration) {
            const appContent = { type: '0x2f Downlink ack' };
            appContent['downlinkFramecode'] = '0x' + payload[2].toString(16);
            appContent['requestStatus'] = this.getRequestStatusText(payload[3]);
            return appContent;
        }
        /**
         * Get Type text
         * @param value value
         */
        getRequestStatusText(value) {
            switch (value) {
                case 1:
                    return 'success';
                case 2:
                    return 'errorGeneric';
                case 3:
                    return 'errorWrongState';
                case 4:
                    return 'errorInvalidRequest';
                default:
                    return 'errorOtherReason';
            }
        }
    }
    codec.Generic0x2fParser = Generic0x2fParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Generic 0x30 (keep alive) frame parser
     */
    class Generic0x30Parser {
        deviceType = 'any';
        frameCode = 0x30;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x30 Keep alive' };
            return appContent;
        }
    }
    codec.Generic0x30Parser = Generic0x30Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Generic 0x33 (Response to Set Register downlink) frame parser
     */
    class Generic0x33Parser {
        deviceType = 'drycontacts|drycontacts2|pulse3|pulse4|' + 'temp3|temp4|comfort|comfort2|comfortCo2|modbus|motion|deltap|breath|comfortSerenity';
        frameCode = 0x33;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x33 Set register status' };
            appContent['requestStatus'] = this.getRequestStatusText(payload[2]);
            appContent['registerId'] = payload.readUInt16BE(3);
            return appContent;
        }
        /**
         * Get Type text
         * @param value value
         */
        getRequestStatusText(value) {
            switch (value) {
                case 1:
                    return 'success';
                case 2:
                    return 'successNoUpdate';
                case 3:
                    return 'errorCoherency';
                case 4:
                    return 'errorInvalidRegister';
                case 5:
                    return 'errorInvalidValue';
                case 6:
                    return 'errorTruncatedValue';
                case 7:
                    return 'errorAccesNotAllowed';
                default:
                    return 'errorOtherReason';
            }
        }
    }
    codec.Generic0x33Parser = Generic0x33Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Generic 0x36 alert message frame parser
     */
    class Generic0x36Parser {
        deviceType = 'temp4';
        frameCode = 0x36;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x36 Alert message' };
            switch (payload[2]) {
                case 0x00:
                    appContent['alertCode'] = 'normalState';
                    break;
                case 0x01:
                    appContent['alertCode'] = 'uplinkDownlinkForbidden';
                    break;
                default:
                    break;
            }
            return appContent;
        }
    }
    codec.Generic0x36Parser = Generic0x36Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Generic 0x37 Software version' frame parser
     */
    class Generic0x37Parser {
        deviceType = 'temp4|comfort2|comfortCo2|breath|comfortSerenity|modbus';
        frameCode = 0x37;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x37 Software version' };
            appContent['appVersion'] = payload.readUInt8(2) + '.' + payload.readUInt8(3) + '.' + payload.readUInt8(4);
            appContent['rtuVersion'] = payload.readUInt8(5) + '.' + payload.readUInt8(6) + '.' + payload.readUInt8(7);
            return appContent;
        }
    }
    codec.Generic0x37Parser = Generic0x37Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Smart digital input 1 alarm frame parser
     */
    class Generic0x51Parser {
        deviceType = 'motion|comfort|comfort2|comfortCo2|deltap|breath|comfortSerenity';
        frameCode = 0x51;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x51 digital input 1 alarm' };
            if (payload[1] & 0x04) {
                // retrieval of the frame date timestamp value,
                // then conversion to epoch 2013 (+1356998400), then in second
                const myDate = new Date((payload.readUInt32BE(9) + 1356998400) * 1000);
                // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
                appContent['timestamp'] = myDate.toJSON().replace('Z', '');
            }
            appContent['state'] = {
                previousFrame: Boolean((payload.readUInt8(2) >> 1) & 1),
                current: Boolean((payload.readUInt8(2) >> 0) & 1),
            };
            appContent['counter'] = {
                global: payload.readUInt32BE(3),
                instantaneous: payload.readUInt16BE(7),
            };
            return appContent;
        }
    }
    codec.Generic0x51Parser = Generic0x51Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * 0x52 digital input 2 alarm frame parser
     */
    class Generic0x52Parser {
        deviceType = 'motion|comfort|comfort2|comfortCo2|deltap|breath|comfortSerenity';
        frameCode = 0x52;
        parser = new codec.Generic0x51Parser();
        parseFrame(payload, configuration, network) {
            const appContent = {
                ...this.parser.parseFrame(payload, configuration, network),
                type: '0x52 digital input 2 alarm',
            };
            return appContent;
        }
    }
    codec.Generic0x52Parser = Generic0x52Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Extended status byte parser
     */
    class GenericStatusByteExtParser {
        deviceType = 'any';
        frameCode = 0;
        parseFrame(payload, configuration) {
            let statusContent = {};
            const parser = new codec.GenericStatusByteParser();
            statusContent = parser.parseFrame(payload, configuration);
            // Status byte, applicative flags
            statusContent['configurationInconsistency'] = Boolean(payload[1] & 0x08);
            return { status: statusContent };
        }
    }
    codec.GenericStatusByteExtParser = GenericStatusByteExtParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Generic status byte parser
     */
    class GenericStatusByteParser {
        deviceType = 'any';
        frameCode = 0;
        parseFrame(payload, configuration) {
            const statusContent = {};
            statusContent['frameCounter'] = (payload[1] & 0xe0) >> 5;
            // hardwareError not used anymore. Currently used for timestamp activation
            statusContent['hardwareError'] = false;
            statusContent['lowBattery'] = Boolean(payload[1] & 0x02);
            statusContent['configurationDone'] = Boolean(payload[1] & 0x01);
            return statusContent;
        }
    }
    codec.GenericStatusByteParser = GenericStatusByteParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Modbus 0x10 (configuration) frame parser
     */
    class Modbus0x10Parser {
        deviceType = 'modbus';
        frameCode = 0x10;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x10 Modbus configuration' };
            appContent['transmissionPeriodKeepAlive'] = { unit: 's', value: payload.readUInt16BE(2) * 10 };
            appContent['transmissionPeriod1'] = { unit: 's', value: payload.readUInt16BE(4) * 10 };
            appContent['samplingPeriod'] = { unit: 's', value: payload.readUInt16BE(6) * 10 };
            appContent['modbusConfiguration'] = payload[8];
            appContent['supplyTime'] = { unit: 's', value: payload.readUInt16BE(9) / 10 };
            return appContent;
        }
    }
    codec.Modbus0x10Parser = Modbus0x10Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Modbus 0x44 (historic data) frame parser
     */
    class Modbus0x44Parser {
        deviceType = 'modbus';
        frameCode = 0x44;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x44 Modbus data (int32)' };
            const registers = [];
            for (let offset = 2; offset < payload.length; offset += 4) {
                registers.push(payload.readInt32BE(offset));
            }
            appContent['registerValues'] = registers;
            return appContent;
        }
    }
    codec.Modbus0x44Parser = Modbus0x44Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Modbus 0x45 (alarm) frame parser
     */
    class Modbus0x45Parser {
        deviceType = 'modbus';
        frameCode = 0x45;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x45 Modbus alarm' };
            appContent['alarmStatus'] = this.getAlarmStatusText(payload.readUInt8(2));
            appContent['slaveAdress'] = payload.readUInt8(3);
            appContent['registerAddress'] = payload.readUInt16BE(4);
            appContent['registerUint16Value1'] = payload.readUInt16BE(6);
            if (payload.length == 10) {
                appContent['registerUint16Value2'] = payload.readUInt16BE(8);
            }
            return appContent;
        }
        /**
         * Get Alarm status text
         * @param value value
         */
        getAlarmStatusText(value) {
            switch (value) {
                case 1:
                    return 'highThreshold';
                case 2:
                    return 'lowThreshold';
                default:
                    return 'none';
            }
        }
    }
    codec.Modbus0x45Parser = Modbus0x45Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Modbus 0x4e (historic data) frame parser
     */
    class Modbus0x5eParser {
        deviceType = 'modbus';
        frameCode = 0x5e;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x5e Modbus read registers' };
            const registers = [];
            for (let offset = 2; offset < payload.length; offset += 2) {
                registers.push(payload.readUInt16BE(offset));
            }
            appContent['registerUint16Values'] = registers;
            return appContent;
        }
    }
    codec.Modbus0x5eParser = Modbus0x5eParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Modbus 0x4f (historic data) frame parser
     */
    class Modbus0x5fParser {
        deviceType = 'modbus';
        frameCode = 0x5f;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x5f Modbus data (int32)' };
            const registers = [];
            for (let offset = 2; offset < payload.length; offset += 4) {
                registers.push(payload.readInt32BE(offset));
            }
            appContent['registerValues'] = registers;
            return appContent;
        }
    }
    codec.Modbus0x5fParser = Modbus0x5fParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Modbus 0x60 (historic data) frame parser
     */
    class Modbus0x60Parser {
        deviceType = 'modbus';
        frameCode = 0x60;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x60 Modbus data (float)' };
            const registers = [];
            for (let offset = 2; offset < payload.length; offset += 4) {
                registers.push(payload.readFloatBE(offset));
            }
            appContent['registerValues'] = registers;
            return appContent;
        }
    }
    codec.Modbus0x60Parser = Modbus0x60Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Modbus 0x61 (historic data) frame parser
     */
    class Modbus0x61Parser {
        deviceType = 'modbus';
        frameCode = 0x61;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x61 Modbus data (float)' };
            const registers = [];
            for (let offset = 2; offset < payload.length; offset += 4) {
                registers.push(payload.readFloatBE(offset));
            }
            appContent['registerValues'] = registers;
            return appContent;
        }
    }
    codec.Modbus0x61Parser = Modbus0x61Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Modbus 0x62 (historic data) frame parser
     */
    class Modbus0x62Parser {
        deviceType = 'modbus';
        frameCode = 0x62;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x62 Modbus data (uint32)' };
            const registers = [];
            for (let offset = 2; offset < payload.length; offset += 4) {
                registers.push(payload.readUInt32BE(offset));
            }
            appContent['registerValues'] = registers;
            return appContent;
        }
    }
    codec.Modbus0x62Parser = Modbus0x62Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Modbus 0x63 (historic data) frame parser
     */
    class Modbus0x63Parser {
        deviceType = 'modbus';
        frameCode = 0x63;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x63 Modbus data (uint32)' };
            const registers = [];
            for (let offset = 2; offset < payload.length; offset += 4) {
                registers.push(payload.readUInt32BE(offset));
            }
            appContent['registerValues'] = registers;
            return appContent;
        }
    }
    codec.Modbus0x63Parser = Modbus0x63Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Pulse status byte parser
     */
    class ModbusStatusByteParser {
        deviceType = 'modbus';
        frameCode = 0;
        parseFrame(payload, configuration) {
            const statusContent = {};
            statusContent['frameCounter'] = (payload[1] & 0xe0) >> 5;
            statusContent['configurationDone'] = Boolean(payload[1] & 0x01);
            statusContent['lowBattery'] = Boolean(payload[1] & 0x02);
            statusContent['hardwareError'] = Boolean(payload[1] & 0x04);
            statusContent['configurationInconsistency'] = Boolean(payload[1] & 0x08);
            statusContent['modbusReadError'] = Boolean(payload[1] & 0x10);
            return { status: statusContent };
        }
    }
    codec.ModbusStatusByteParser = ModbusStatusByteParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Motion 0x10 (configuration) frame parser
     */
    class Motion0x10Parser {
        deviceType = 'motion';
        frameCode = 0x10;
        parseFrame(payload, configuration, network) {
            // register 300: Emission period of the life frame X 10s
            // register 301: Issue period, value betwenn 0 and 65535, 0: disabling periodic transmission
            // register 320: value between 1 and 65535
            // register 321: value between 0 and 65535, 0: no scanning, X2s
            // register 322: presence inhibition period X 10s
            // reading_frequency = S321 * S320
            // sending_frequency = S321 * S320 * S301
            const appContent = { type: '0x10 Motion configuration' };
            (appContent['transmissionPeriodKeepAlive'] = { unit: 's', value: payload.readUInt16BE(2) * 10 }),
                (appContent['numberOfHistorizationBeforeSending'] = payload.readUInt16BE(4)),
                (appContent['numberOfSamplingBeforeHistorization'] = payload.readUInt16BE(6)),
                (appContent['samplingPeriod'] = { unit: 's', value: payload.readUInt16BE(8) * 2 }),
                (appContent['presenceDetectorInhibition'] = { unit: 's', value: payload.readUInt16BE(10) * 10 }),
                (appContent['calculatedPeriodRecording'] = {
                    unit: 's',
                    value: payload.readUInt16BE(8) * payload.readUInt16BE(6) * 2,
                }),
                (appContent['calculatedSendingPeriod'] = {
                    unit: 's',
                    value: payload.readUInt16BE(8) * payload.readUInt16BE(6) * payload.readUInt16BE(4) * 2,
                });
            return appContent;
        }
    }
    codec.Motion0x10Parser = Motion0x10Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Motion 0x4e (historic data) frame parser
     */
    class Motion0x4eParser {
        deviceType = 'motion';
        frameCode = 0x4e;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x4e Motion data' };
            const counters = [], luminosities = [];
            appContent['globalCounterValue'] = payload.readUInt16BE(2);
            // Loop through historic data [t=0, t-1, t-2,...]
            for (let offset = 4; offset < payload.length; offset += 3) {
                counters.push(payload.readInt16BE(offset));
                luminosities.push(payload.readUInt8(offset + 2));
            }
            appContent['decodingInfo'] = 'counterValues/values: [t=0, t-1, t-2, ...]';
            appContent['counterValues'] = counters;
            appContent['luminosity'] = { unit: '\u0025', values: luminosities };
            return appContent;
        }
    }
    codec.Motion0x4eParser = Motion0x4eParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Motion 0x4f (presence alarm) frame parser
     */
    class Motion0x4fParser {
        deviceType = 'motion';
        frameCode = 0x4f;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x4f Motion presence alarm' };
            appContent['alarmPresence'] = {
                globalCounterValue: payload.readUInt16BE(2),
                counterValue: payload.readUInt16BE(4),
            };
            return appContent;
        }
    }
    codec.Motion0x4fParser = Motion0x4fParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Motion 0x50 (luminosity alarm) frame parser
     */
    class Motion0x50Parser {
        deviceType = 'motion';
        frameCode = 0x50;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x50 Motion luminosity alarm' };
            appContent['alarmLuminosity'] = {
                alarmStatus: payload[2] ? 'active' : 'inactive',
                luminosity: { unit: '\u0025', value: payload[3] },
            };
            return appContent;
        }
    }
    codec.Motion0x50Parser = Motion0x50Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Motion 0x5c (historic data) frame parser
     */
    class Motion0x5cParser {
        deviceType = 'motion';
        frameCode = 0x5c;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x5c Motion data' };
            const presences = [], luminosities = [];
            appContent['presenceDetectedWhenSending'] = Boolean(payload[2]);
            // Loop through historic data [t=0, t-1, t-2,...]
            for (let offset = 3; offset < payload.length; offset += 2) {
                presences.push(payload[offset]);
                luminosities.push(payload[offset + 1]);
            }
            appContent['decodingInfo'] = 'values: [t=0, t-1, t-2, ...]';
            appContent['presence'] = { unit: '\u0025', values: presences };
            appContent['luminosity'] = { unit: '\u0025', values: luminosities };
            return appContent;
        }
    }
    codec.Motion0x5cParser = Motion0x5cParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Motion 0x4f (presence alarm) frame parser
     */
    class Motion0x5dParser {
        deviceType = 'motion';
        frameCode = 0x5d;
        parseFrame(payload, configuration, network) {
            const appContent = {
                type: '0x5d Motion presence alarm',
            };
            appContent['alarmPresence'] = {
                alarmStatus: payload[2] ? 'active' : 'inactive',
                luminosity: { unit: '\u0025', value: payload[3] },
            };
            return appContent;
        }
    }
    codec.Motion0x5dParser = Motion0x5dParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Pulse 0x10 (configuration) frame parser
     */
    class Pulse0x10Parser {
        deviceType = 'pulse';
        frameCode = 0x10;
        pulse0x11Parser = new codec.Pulse0x11Parser();
        pulse0x12Parser = new codec.Pulse0x12Parser();
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x10 Pulse configuration' };
            const chA = { name: 'channel A' };
            const chB = { name: 'channel B' };
            // Product mode
            appContent['productMode'] = codec.PlateformCommonUtils.getProductModeText(payload[2]);
            // Resolve known network
            const knownNetwork = this.inferNetwork(payload.length);
            // Transmission period
            let offset = 0;
            if (payload[8] === 2) {
                // TEST mode => period = value * 20sec
                if (knownNetwork === 'sigfox') {
                    appContent['transmissionPeriod'] = { unit: 's', value: payload[3] * 20 };
                    offset = -1; // value is on 1 byte for Sigfox, shift further payload reading
                }
                else {
                    appContent['transmissionPeriod'] = { unit: 's', value: payload.readUInt16BE(3) * 20 };
                }
            }
            else {
                // PRODUCTION mode
                if (knownNetwork === 'sigfox') {
                    // Sigfox: period = value * 10min
                    appContent['transmissionPeriod'] = { unit: 'm', value: payload[3] * 10 };
                    offset = -1; // value is on 1 byte for Sigfox, shift further payload reading
                }
                else {
                    // LoRa 868: period = value * 1min
                    appContent['transmissionPeriod'] = { unit: 'm', value: payload.readUInt16BE(3) };
                }
            }
            // Flow calculation period
            if (payload[2] === 2) {
                // TEST mode => period = value * 20sec
                appContent['flowCalculationPeriod'] = { unit: 's', value: payload.readUInt16BE(offset + 8) * 20 };
            }
            else {
                // PRODUCTION mode => period = value * 1min
                appContent['flowCalculationPeriod'] = { unit: 'm', value: payload.readUInt16BE(offset + 8) };
            }
            // Historic mode
            appContent['historicMode'] = this.getHistoricModeText(payload[offset + 6]);
            // Channels A configuration
            chA['state'] = this.getStateText(Boolean(payload[offset + 5] & 0x01));
            chA['type'] = this.getTypeText(Boolean(payload[offset + 5] & 0x02));
            chA['tamperActivated'] = Boolean(payload[offset + 5] & 0x08);
            chA['debouncingPeriod'] = {
                unit: 'ms',
                value: this.getDebouncingPeriod(payload[offset + 7] & 0x0f),
            };
            if (knownNetwork === 'lora868') {
                chA['leakageDetection'] = {
                    overflowAlarmTriggerThreshold: payload.readUInt16BE(10),
                    threshold: payload.readUInt16BE(14),
                    dailyPeriodsBelowWhichLeakageAlarmTriggered: payload.readUInt16BE(18),
                };
            }
            // Channels B configuration
            chB['state'] = this.getStateText(Boolean(payload[offset + 5] & 0x10));
            chB['type'] = this.getTypeText(Boolean(payload[offset + 5] & 0x20));
            chB['tamperActivated'] = Boolean(payload[offset + 5] & 0x80);
            chB['debouncingPeriod'] = {
                unit: 'ms',
                value: this.getDebouncingPeriod((payload[offset + 7] & 0xf0) >> 4),
            };
            if (knownNetwork === 'lora868') {
                chB['leakageDetection'] = {
                    overflowAlarmTriggerThreshold: payload.readUInt16BE(12),
                    threshold: payload.readUInt16BE(16),
                    dailyPeriodsBelowWhichLeakageAlarmTriggered: payload.readUInt16BE(20),
                };
            }
            appContent['channels'] = [chA, chB];
            return appContent;
        }
        /**
         * Infer network
         * @param length frame length
         */
        inferNetwork(length) {
            //            +--------------+
            //            | Frame length |
            // +----------+--------------+
            // | LoRa 868 |           22 |
            // | Sigfox   |            9 |
            // +----------+--------------+
            switch (length) {
                case 22:
                    return 'lora868';
                case 9:
                    return 'sigfox';
                default:
                    return 'unknown';
            }
        }
        /**
         * Get state text
         * @param value value
         */
        getStateText(value) {
            return value ? 'enabled' : 'disabled';
        }
        /**
         * Get type text
         * @param value value
         */
        getTypeText(value) {
            return value ? 'gasPullUpOn' : 'otherPullUpOff';
        }
        /**
         * Get historic mode text
         * @param value value
         */
        getHistoricModeText(value) {
            switch (value) {
                case 0:
                    return 'noHistoric';
                case 1:
                    return 'historicLogEvery10min';
                case 2:
                    return 'historicLogEvery1h';
                default:
                    return '';
            }
        }
        /**
         * Get debouncing period text
         * @param value value
         */
        getDebouncingPeriod(value) {
            switch (value) {
                case 0:
                    return 0;
                case 1:
                    return 1;
                case 2:
                    return 10;
                case 3:
                    return 20;
                case 4:
                    return 50;
                case 5:
                    return 100;
                case 6:
                    return 200;
                case 7:
                    return 500;
                case 8:
                    return 1000;
                case 9:
                    return 2000;
                case 10:
                    return 5000;
                case 11:
                    return 10000;
                default:
                    return 0;
            }
        }
    }
    codec.Pulse0x10Parser = Pulse0x10Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Pulse 0x11 (configuration) frame parser
     */
    class Pulse0x11Parser {
        deviceType = 'pulse';
        frameCode = 0x11;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x11 Pulse configuration' };
            const chA = { name: 'channel A' };
            const chB = { name: 'channel B' };
            chA['leakageDetection'] = {
                overflowAlarmTriggerThreshold: payload.readUInt16BE(2),
                threshold: payload.readUInt16BE(6),
            };
            chB['leakageDetection'] = {
                overflowAlarmTriggerThreshold: payload.readUInt16BE(4),
                threshold: payload.readUInt16BE(8),
            };
            appContent['channels'] = [chA, chB];
            return appContent;
        }
    }
    codec.Pulse0x11Parser = Pulse0x11Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Pulse 0x12 (configuration) frame parser
     */
    class Pulse0x12Parser {
        deviceType = 'pulse';
        frameCode = 0x12;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x12 Pulse configuration' };
            const chA = { name: 'channel A' };
            const chB = { name: 'channel B' };
            chA['leakageDetection'] = {
                dailyPeriodsBelowWhichLeakageAlarmTriggered: payload.readUInt16BE(2),
            };
            chB['leakageDetection'] = {
                dailyPeriodsBelowWhichLeakageAlarmTriggered: payload.readUInt16BE(4),
            };
            appContent['channels'] = [chA, chB];
            return appContent;
        }
    }
    codec.Pulse0x12Parser = Pulse0x12Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Pulse 0x30 (keep alive) frame parser
     */
    class Pulse0x30Parser {
        deviceType = 'pulse';
        frameCode = 0x30;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x30 Pulse keep alive' };
            const chA = { name: 'channel A' };
            const chB = { name: 'channel B' };
            chA['flow'] = {
                alarm: Boolean(payload[2] & 0x01),
                last24hMin: payload.readUInt16BE(7),
                last24hMax: payload.readUInt16BE(3),
            };
            chA['tamperAlarm'] = Boolean(payload[2] & 0x04);
            chA['leakageAlarm'] = Boolean(payload[2] & 0x10);
            chB['flow'] = {
                alarm: Boolean(payload[2] & 0x02),
                last24hMin: payload.readUInt16BE(9),
                last24hMax: payload.readUInt16BE(5),
            };
            chB['tamperAlarm'] = Boolean(payload[2] & 0x08);
            chB['leakageAlarm'] = Boolean(payload[2] & 0x20);
            appContent['channels'] = [chA, chB];
            return appContent;
        }
    }
    codec.Pulse0x30Parser = Pulse0x30Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Pulse 0x46 (data) frame parser
     */
    class Pulse0x46Parser {
        deviceType = 'pulse';
        frameCode = 0x46;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x46 Pulse data' };
            appContent['decodingInfo'] = 'counterValues: [Channel A, Channel B]';
            // Current indexes [Channel A, Channel B]
            appContent['counterValues'] = [payload.readUInt32BE(2), payload.readUInt32BE(6)];
            return appContent;
        }
    }
    codec.Pulse0x46Parser = Pulse0x46Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Pulse 0x47 (alarm) frame parser
     */
    class Pulse0x47Parser {
        deviceType = 'pulse';
        frameCode = 0x47;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x47 Pulse alarm' };
            appContent['decodingInfo'] = 'flowValues: [Channel A, Channel B]';
            // Flows when overflow has occured [Channel A, Channel B]
            appContent['flowValues'] = [payload.readUInt16BE(2), payload.readUInt16BE(4)];
            return appContent;
        }
    }
    codec.Pulse0x47Parser = Pulse0x47Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Pulse 0x48 (historic data) frame parser
     */
    class Pulse0x48Parser {
        deviceType = 'pulse';
        frameCode = 0x48;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x48 Pulse historic data' };
            const deltasA = [];
            const deltasB = [];
            const chA = { name: 'channel A' };
            const chB = { name: 'channel B' };
            // Frame index
            const frameIndex = payload[2];
            appContent['frameIndex'] = frameIndex;
            if (frameIndex === 0) {
                // Index values
                chA['index'] = payload.readUInt32BE(3);
                chB['index'] = payload.readUInt32BE(7);
            }
            // Delta values
            const start = frameIndex === 0 ? 11 : 3;
            const base = this.getBase(frameIndex, payload.length);
            for (let offset = start; offset < payload.length; offset += 4) {
                deltasA.push(payload.readUInt16BE(offset));
                deltasB.push(payload.readUInt16BE(offset + 2));
            }
            if (deltasA.length > 0) {
                appContent['baseTime'] = base;
                appContent['decodingInfo'] = `deltaValues: [t=${base} to t=${base + 1}, t=${base + 1} to t=${base + 2}, ...]`;
                chA['deltaValues'] = deltasA;
                chB['deltaValues'] = deltasB;
            }
            appContent['channels'] = [chA, chB];
            return appContent;
        }
        /**
         * Based on frameIndex and payload length this routine determines the basetime (different in lora and SFX)
         * @param payload payload
         * @param configuration configuration
         */
        getBase(frameIndex, byteLength) {
            if (byteLength === 31 || byteLength === 51) {
                return [1, 11][frameIndex];
            }
            else if ((frameIndex === 2 && byteLength === 7) || (frameIndex === 12 && byteLength === 7)) {
                return 23;
            }
            else if (frameIndex === 3 && byteLength === 7) {
                return 5;
            }
            else if (byteLength === 11) {
                return [1, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23][frameIndex];
            }
            else {
                // Unknown
                return 0;
            }
        }
    }
    codec.Pulse0x48Parser = Pulse0x48Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Pulse status byte parser
     */
    class PulseStatusByteParser {
        deviceType = 'pulse';
        frameCode = 0;
        parseFrame(payload, configuration) {
            let statusContent = {};
            const parser = new codec.GenericStatusByteParser();
            statusContent = parser.parseFrame(payload, configuration);
            return { status: statusContent };
        }
    }
    codec.PulseStatusByteParser = PulseStatusByteParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Pulse 3 0x10 (configuration) frame parser
     */
    class PulseV30x10Parser {
        deviceType = 'pulse3';
        frameCode = 0x10;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x10 Pulse 3 configuration' };
            const chA = { name: 'channel A' };
            const chB = { name: 'channel B' };
            // Product mode
            appContent['productMode'] = codec.PlateformCommonUtils.getProductModeText(payload[2]);
            // Resolve known network
            const knownNetwork = this.inferNetwork(payload.length);
            // Transmission period
            appContent['numberOfHistorizationBeforeSending'] = payload.readUInt16BE(3);
            appContent['samplingPeriod'] = { unit: 's', value: payload.readUInt16BE(6) * 2 };
            appContent['calculatedSendingPeriod'] = {
                unit: 's',
                value: payload.readUInt16BE(3) * payload.readUInt16BE(6) * 2,
            };
            // Flow calculation period
            if (payload[2] === 2) {
                // TEST mode => period = value * 20sec
                appContent['flowCalculationPeriod'] = { unit: 's', value: payload.readUInt16BE(9) * 20 };
            }
            else {
                // PRODUCTION mode => period = value * 1min
                appContent['flowCalculationPeriod'] = { unit: 'm', value: payload.readUInt16BE(9) };
            }
            if (knownNetwork === 'lora868') {
                appContent['redundantSamples'] = payload.readUInt8(27);
            }
            // Channels A configuration
            chA['state'] = this.getStateText(Boolean(payload[5] & 0x01));
            chA['type'] = this.getTypeText(Boolean(payload[5] & 0x02));
            chA['debouncingPeriod'] = {
                unit: 'ms',
                value: this.getDebouncingPeriodText(payload[8] & 0x0f),
            };
            if (knownNetwork === 'lora868') {
                chA['leakageDetection'] = {
                    overflowAlarmTriggerThreshold: payload.readUInt16BE(11),
                    threshold: payload.readUInt16BE(15),
                    dailyPeriodsBelowWhichLeakageAlarmTriggered: payload.readUInt16BE(19),
                };
                chA['tamper'] = {
                    activated: Boolean(payload[5] & 0x08),
                    samplePeriodForDetection: { unit: 's', value: payload.readUInt8(23) * 10 },
                    threshold: payload.readUInt8(24),
                };
            }
            else if (knownNetwork === 'sigfox') {
                chA['tamper'] = { activated: Boolean(payload[5] & 0x08) };
            }
            // Channel B configuration
            chB['state'] = this.getStateText(Boolean(payload[5] & 0x10));
            chB['type'] = this.getTypeText(Boolean(payload[5] & 0x20));
            chB['debouncingPeriod'] = {
                unit: 'ms',
                value: this.getDebouncingPeriodText((payload[8] & 0xf0) >> 4),
            };
            if (knownNetwork === 'lora868') {
                chB['leakageDetection'] = {
                    overflowAlarmTriggerThreshold: payload.readUInt16BE(13),
                    threshold: payload.readUInt16BE(17),
                    dailyPeriodsBelowWhichLeakageAlarmTriggered: payload.readUInt16BE(21),
                };
                chB['tamper'] = {
                    activated: Boolean(payload[5] & 0x80),
                    samplePeriodForDetection: { unit: 's', value: payload.readUInt8(25) * 10 },
                    threshold: payload.readUInt8(26),
                };
            }
            else if (knownNetwork === 'sigfox') {
                chB['tamper'] = { activated: Boolean(payload[5] & 0x80) };
            }
            appContent['channels'] = [chA, chB];
            return appContent;
        }
        /**
         * Infer network
         * @param length frame length
         */
        inferNetwork(length) {
            //            +--------------+
            //            | Frame length |
            // +----------+--------------+
            // | LoRa 868 |           22 |
            // | Sigfox   |            9 |
            // +----------+--------------+
            switch (length) {
                case 28:
                    return 'lora868';
                case 11:
                    return 'sigfox';
                default:
                    return 'unknown';
            }
        }
        /**
         * Get state text
         * @param value value
         */
        getStateText(value) {
            return value ? 'enabled' : 'disabled';
        }
        /**
         * Get type text
         * @param value value
         */
        getTypeText(value) {
            return value ? 'gasPullUpOn' : 'otherPullUpOff';
        }
        /**
         * Get debouncing period text
         * @param value value
         */
        getDebouncingPeriodText(value) {
            switch (value) {
                case 0:
                    return 0;
                case 1:
                    return 1;
                case 2:
                    return 10;
                case 3:
                    return 20;
                case 4:
                    return 50;
                case 5:
                    return 100;
                case 6:
                    return 200;
                case 7:
                    return 500;
                case 8:
                    return 1000;
                case 9:
                    return 2000;
                case 10:
                    return 5000;
                case 11:
                    return 10000;
                default:
                    return 0;
            }
        }
    }
    codec.PulseV30x10Parser = PulseV30x10Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Pulse 0x11 (configuration) frame parser
     */
    class PulseV30x11Parser {
        deviceType = 'pulse3';
        frameCode = 0x11;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x11 Pulse 3 configuration' };
            const chA = { name: 'channel A' };
            const chB = { name: 'channel B' };
            chA['leakageDetection'] = {
                overflowAlarmTriggerThreshold: payload.readUInt16BE(2),
                threshold: payload.readUInt16BE(6),
            };
            chB['leakageDetection'] = {
                overflowAlarmTriggerThreshold: payload.readUInt16BE(4),
                threshold: payload.readUInt16BE(8),
            };
            appContent['channels'] = [chA, chB];
            return appContent;
        }
    }
    codec.PulseV30x11Parser = PulseV30x11Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Pulse 3 0x12 (configuration) frame parser
     */
    class PulseV30x12Parser {
        deviceType = 'pulse3';
        frameCode = 0x12;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x12 Pulse 3 configuration' };
            const chA = { name: 'channel A' };
            const chB = { name: 'channel B' };
            chA['leakageDetection'] = {
                dailyPeriodsBelowWhichLeakageAlarmTriggered: payload.readUInt16BE(2),
            };
            chA['tamper'] = {
                samplePeriodForDetection: { unit: 's', value: payload.readUInt8(6) * 10 },
                threshold: payload.readUInt8(7),
            };
            chB['leakageDetection'] = {
                dailyPeriodsBelowWhichLeakageAlarmTriggered: payload.readUInt16BE(4),
            };
            chB['tamper'] = {
                samplePeriodForDetection: { unit: 's', value: payload.readUInt8(8) * 10 },
                threshold: payload.readUInt8(9),
            };
            appContent['channels'] = [chA, chB];
            return appContent;
        }
    }
    codec.PulseV30x12Parser = PulseV30x12Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Pulse 3 0x30 (keep alive) frame parser
     */
    class PulseV30x30Parser {
        deviceType = 'pulse3';
        frameCode = 0x30;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x30 Pulse 3 keep alive' };
            const chA = { name: 'channel A' };
            const chB = { name: 'channel B' };
            chA['flow'] = {
                alarm: Boolean(payload[2] & 0x01),
                last24hMin: payload.readUInt16BE(7),
                last24hMax: payload.readUInt16BE(3),
            };
            chA['tamperAlarm'] = Boolean(payload[2] & 0x04);
            chA['leakageAlarm'] = Boolean(payload[2] & 0x10);
            chB['flow'] = {
                alarm: Boolean(payload[2] & 0x02),
                last24hMin: payload.readUInt16BE(9),
                last24hMax: payload.readUInt16BE(5),
            };
            chB['tamperAlarm'] = Boolean(payload[2] & 0x08);
            chB['leakageAlarm'] = Boolean(payload[2] & 0x20);
            appContent['channels'] = [chA, chB];
            return appContent;
        }
    }
    codec.PulseV30x30Parser = PulseV30x30Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Pulse 3 0x46 (data) frame parser
     */
    class PulseV30x46Parser {
        deviceType = 'pulse3';
        frameCode = 0x46;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x46 Pulse 3 data' };
            appContent['decodingInfo'] = 'counterValues: [Channel A, Channel B]';
            // Current indexes [Channel A, Channel B]
            appContent['counterValues'] = [payload.readUInt32BE(2), payload.readUInt32BE(6)];
            return appContent;
        }
    }
    codec.PulseV30x46Parser = PulseV30x46Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Pulse 3 0x47 (alarm) frame parser
     */
    class PulseV30x47Parser {
        deviceType = 'pulse3';
        frameCode = 0x47;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x47 Pulse 3 alarm' };
            appContent['decodingInfo'] = 'flowValues: [Channel A, Channel B]';
            // Flows when overflow occured [Channel A, Channel B]
            appContent['flowValues'] = [payload.readUInt16BE(2), payload.readUInt16BE(4)];
            return appContent;
        }
    }
    codec.PulseV30x47Parser = PulseV30x47Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Pulse 3 periodic data  frame parser
     */
    class PulseV30x5aParser {
        deviceType = 'pulse3';
        frameCode = 0x5a;
        parseFrame(payload, configuration, network) {
            let absCounterValue = payload.readUInt32BE(2);
            const appContent = { type: '0x5a Pulse 3 data - channel A' };
            const values = [absCounterValue];
            // Loop through historic data [t=0, t-1, t-2,...]
            for (let offset = 6; offset < payload.length; offset += 2) {
                absCounterValue -= payload.readUInt16BE(offset);
                values.push(absCounterValue);
            }
            appContent['decodingInfo'] = 'counterValues: [t=0, t-1, t-2, ...]';
            appContent['counterValues'] = values;
            return appContent;
        }
        /**
         * Get reading frequency
         * @param configuration configuration
         */
        getReadingFrequency(configuration) {
            return configuration.byteLength > 0 ? configuration.readUInt16BE(8) * configuration.readUInt16BE(6) * 2 : null;
        }
    }
    codec.PulseV30x5aParser = PulseV30x5aParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Pulse 3 periodic data frame parser
     */
    class PulseV30x5bParser {
        deviceType = 'pulse3';
        frameCode = 0x5b;
        parseFrame(payload, configuration, network) {
            let absCounterValue = payload.readUInt32BE(2);
            const appContent = { type: '0x5b Pulse 3 data - channel B' };
            const values = [absCounterValue];
            // Loop through historic data [t=0, t-1, t-2,...]
            for (let offset = 6; offset < payload.length; offset += 2) {
                absCounterValue -= payload.readUInt16BE(offset);
                values.push(absCounterValue);
            }
            appContent['decodingInfo'] = 'counterValues: [t=0, t-1, t-2, ...]';
            appContent['counterValues'] = values;
            return appContent;
        }
        /**
         * Get reading frequency
         * @param configuration configuration
         */
        getReadingFrequency(configuration) {
            return configuration.byteLength > 0 ? configuration.readUInt16BE(8) * configuration.readUInt16BE(6) * 2 : null;
        }
    }
    codec.PulseV30x5bParser = PulseV30x5bParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Pulse 4 0x10 (configuration) frame parser
     */
    class PulseV40x10Parser {
        deviceType = 'pulse4';
        frameCode = 0x10;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x10 Pulse 4 configuration' };
            const chA = { name: 'channel A' };
            const chB = { name: 'channel B' };
            // Product mode
            appContent['productMode'] = codec.PlateformCommonUtils.getProductModeText(payload[2]);
            // Resolve known network
            const knownNetwork = this.inferNetwork(payload.length);
            // Transmission period
            appContent['numberOfHistorizationBeforeSending'] = payload.readUInt16BE(3);
            appContent['samplingPeriod'] = { unit: 's', value: payload.readUInt16BE(6) * 2 };
            appContent['calculatedSendingPeriod'] = {
                unit: 's',
                value: payload.readUInt16BE(3) * payload.readUInt16BE(6) * 2,
            };
            // Flow calculation period
            if (payload[2] === 2) {
                // TEST mode => period = value * 20sec
                appContent['flowCalculationPeriod'] = { unit: 's', value: payload.readUInt16BE(9) * 20 };
            }
            else {
                // PRODUCTION mode => period = value * 1min
                appContent['flowCalculationPeriod'] = { unit: 'm', value: payload.readUInt16BE(9) };
            }
            if (knownNetwork === 'lora868') {
                appContent['redundantSamples'] = payload.readUInt8(27);
            }
            // Channels A configuration
            chA['state'] = this.getStateText(Boolean(payload[5] & 0x01));
            chA['type'] = this.getTypeText(Boolean(payload[5] & 0x02));
            chA['debouncingPeriod'] = {
                unit: 'ms',
                value: this.getDebouncingPeriodText(payload[8] & 0x0f),
            };
            if (knownNetwork === 'lora868') {
                chA['leakageDetection'] = {
                    overflowAlarmTriggerThreshold: payload.readUInt16BE(11),
                    threshold: payload.readUInt16BE(15),
                    dailyPeriodsBelowWhichLeakageAlarmTriggered: payload.readUInt16BE(19),
                };
                chA['tamper'] = {
                    activated: Boolean(payload[5] & 0x08),
                    samplePeriodForDetection: { unit: 's', value: payload.readUInt8(23) * 10 },
                    threshold: payload.readUInt8(24),
                };
            }
            else if (knownNetwork === 'sigfox') {
                chA['tamper'] = { activated: Boolean(payload[5] & 0x08) };
            }
            // Channel B configuration
            chB['state'] = this.getStateText(Boolean(payload[5] & 0x10));
            chB['type'] = this.getTypeText(Boolean(payload[5] & 0x20));
            chB['debouncingPeriod'] = {
                unit: 'ms',
                value: this.getDebouncingPeriodText((payload[8] & 0xf0) >> 4),
            };
            if (knownNetwork === 'lora868') {
                chB['leakageDetection'] = {
                    overflowAlarmTriggerThreshold: payload.readUInt16BE(13),
                    threshold: payload.readUInt16BE(17),
                    dailyPeriodsBelowWhichLeakageAlarmTriggered: payload.readUInt16BE(21),
                };
                chB['tamper'] = {
                    activated: Boolean(payload[5] & 0x80),
                    samplePeriodForDetection: { unit: 's', value: payload.readUInt8(25) * 10 },
                    threshold: payload.readUInt8(26),
                };
            }
            else if (knownNetwork === 'sigfox') {
                chB['tamper'] = { activated: Boolean(payload[5] & 0x80) };
            }
            appContent['channels'] = [chA, chB];
            return appContent;
        }
        /**
         * Infer network
         * @param length frame length
         */
        inferNetwork(length) {
            //            +--------------+
            //            | Frame length |
            // +----------+--------------+
            // | LoRa 868 |           22 |
            // | Sigfox   |            9 |
            // +----------+--------------+
            switch (length) {
                case 28:
                    return 'lora868';
                case 11:
                    return 'sigfox';
                default:
                    return 'unknown';
            }
        }
        /**
         * Get state text
         * @param value value
         */
        getStateText(value) {
            return value ? 'enabled' : 'disabled';
        }
        /**
         * Get type text
         * @param value value
         */
        getTypeText(value) {
            return value ? 'gasPullUpOn' : 'otherPullUpOff';
        }
        /**
         * Get debouncing period text
         * @param value value
         */
        getDebouncingPeriodText(value) {
            switch (value) {
                case 0:
                    return 0;
                case 1:
                    return 1;
                case 2:
                    return 10;
                case 3:
                    return 20;
                case 4:
                    return 50;
                case 5:
                    return 100;
                case 6:
                    return 200;
                case 7:
                    return 500;
                case 8:
                    return 1000;
                case 9:
                    return 2000;
                case 10:
                    return 5000;
                case 11:
                    return 10000;
                default:
                    return 0;
            }
        }
    }
    codec.PulseV40x10Parser = PulseV40x10Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Pulse 0x11 (configuration) frame parser
     */
    class PulseV40x11Parser {
        deviceType = 'pulse4';
        frameCode = 0x11;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x11 Pulse 4 configuration' };
            const chA = { name: 'channel A' };
            const chB = { name: 'channel B' };
            chA['leakageDetection'] = {
                overflowAlarmTriggerThreshold: payload.readUInt16BE(2),
                threshold: payload.readUInt16BE(6),
            };
            chB['leakageDetection'] = {
                overflowAlarmTriggerThreshold: payload.readUInt16BE(4),
                threshold: payload.readUInt16BE(8),
            };
            appContent['channels'] = [chA, chB];
            return appContent;
        }
    }
    codec.PulseV40x11Parser = PulseV40x11Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Pulse 4 0x12 (configuration) frame parser
     */
    class PulseV40x12Parser {
        deviceType = 'pulse4';
        frameCode = 0x12;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x12 Pulse 4 configuration' };
            const chA = { name: 'channel A' };
            const chB = { name: 'channel B' };
            chA['leakageDetection'] = {
                dailyPeriodsBelowWhichLeakageAlarmTriggered: payload.readUInt16BE(2),
            };
            chA['tamper'] = {
                samplePeriodForDetection: { unit: 's', value: payload.readUInt8(6) * 10 },
                threshold: payload.readUInt8(7),
            };
            chB['leakageDetection'] = {
                dailyPeriodsBelowWhichLeakageAlarmTriggered: payload.readUInt16BE(4),
            };
            chB['tamper'] = {
                samplePeriodForDetection: { unit: 's', value: payload.readUInt8(8) * 10 },
                threshold: payload.readUInt8(9),
            };
            appContent['channels'] = [chA, chB];
            return appContent;
        }
    }
    codec.PulseV40x12Parser = PulseV40x12Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Pulse 4 0x30 (keep alive) frame parser
     */
    class PulseV40x30Parser {
        deviceType = 'pulse4';
        frameCode = 0x30;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x30 Pulse 4 keep alive' };
            if (payload[1] & 0x04) {
                // retrieval of the frame date timestamp value, then conversion to epoch 2013 (+1356998400), then in second
                const myDate = new Date((payload.readUInt32BE(11) + 1356998400) * 1000);
                // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
                appContent['timestamp'] = myDate.toJSON().replace('Z', '');
            }
            const chA = { name: 'channel A' };
            const chB = { name: 'channel B' };
            chA['flow'] = {
                alarm: Boolean(payload[2] & 0x01),
                last24hMin: payload.readUInt16BE(7),
                last24hMax: payload.readUInt16BE(3),
            };
            chA['tamperAlarm'] = Boolean(payload[2] & 0x04);
            chA['leakageAlarm'] = Boolean(payload[2] & 0x10);
            chB['flow'] = {
                alarm: Boolean(payload[2] & 0x02),
                last24hMin: payload.readUInt16BE(9),
                last24hMax: payload.readUInt16BE(5),
            };
            chB['tamperAlarm'] = Boolean(payload[2] & 0x08);
            chB['leakageAlarm'] = Boolean(payload[2] & 0x20);
            appContent['channels'] = [chA, chB];
            return appContent;
        }
    }
    codec.PulseV40x30Parser = PulseV40x30Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Pulse 4 0x46 (data) frame parser
     */
    class PulseV40x46Parser {
        deviceType = 'pulse4';
        frameCode = 0x46;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x46 Pulse 4 data' };
            if (payload[1] & 0x04) {
                // retrieval of the frame date timestamp value, then conversion to epoch 2013 (+1356998400), then in second
                const myDate = new Date((payload.readUInt32BE(10) + 1356998400) * 1000);
                // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
                appContent['timestamp'] = myDate.toJSON().replace('Z', '');
            }
            appContent['decodingInfo'] = 'counterValues: [Channel A, Channel B]';
            // Current indexes [Channel A, Channel B]
            appContent['counterValues'] = [payload.readUInt32BE(2), payload.readUInt32BE(6)];
            return appContent;
        }
    }
    codec.PulseV40x46Parser = PulseV40x46Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Pulse 4 0x47 (alarm) frame parser
     */
    class PulseV40x47Parser {
        deviceType = 'pulse4';
        frameCode = 0x47;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x47 Pulse 4 alarm' };
            if (payload[1] & 0x04) {
                // retrieval of the frame date timestamp value, then conversion to epoch 2013 (+1356998400), then in second
                const myDate = new Date((payload.readUInt32BE(6) + 1356998400) * 1000);
                // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
                appContent['timestamp'] = myDate.toJSON().replace('Z', '');
            }
            appContent['decodingInfo'] = 'flowValues: [Channel A, Channel B]';
            // Flows when overflow occured [Channel A, Channel B]
            appContent['flowValues'] = [payload.readUInt16BE(2), payload.readUInt16BE(4)];
            return appContent;
        }
    }
    codec.PulseV40x47Parser = PulseV40x47Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Pulse 4 periodic data  frame parser
     */
    class PulseV40x5aParser {
        deviceType = 'pulse4';
        frameCode = 0x5a;
        parseFrame(payload, configuration, network) {
            let absCounterValue = payload.readUInt32BE(2);
            const appContent = { type: '0x5a Pulse 4 data - channel A' };
            const values = [absCounterValue];
            const payloadLength = payload[1] & 0x04 ? payload.length - 4 : payload.length;
            if (payload[1] & 0x04) {
                // retrieval of the frame date timestamp value, then conversion to epoch 2013 (+1356998400), then in second
                const myDate = new Date((payload.readUInt32BE(payload.length - 4) + 1356998400) * 1000);
                // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
                appContent['timestamp'] = myDate.toJSON().replace('Z', '');
            }
            // Loop through historic data [t=0, t-1, t-2,...]
            for (let offset = 6; offset < payloadLength; offset += 2) {
                absCounterValue -= payload.readUInt16BE(offset);
                values.push(absCounterValue);
            }
            appContent['decodingInfo'] = 'counterValues: [t=0, t-1, t-2, ...]';
            appContent['counterValues'] = values;
            return appContent;
        }
        /**
         * Get reading frequency
         * @param configuration configuration
         */
        getReadingFrequency(configuration) {
            return configuration.byteLength > 0 ? configuration.readUInt16BE(8) * configuration.readUInt16BE(6) * 2 : null;
        }
    }
    codec.PulseV40x5aParser = PulseV40x5aParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Pulse 4 periodic data frame parser
     */
    class PulseV40x5bParser {
        deviceType = 'pulse4';
        frameCode = 0x5b;
        parseFrame(payload, configuration, network) {
            let absCounterValue = payload.readUInt32BE(2);
            const appContent = { type: '0x5b Pulse 4 data - channel B' };
            const values = [absCounterValue];
            const payloadLength = payload[1] & 0x04 ? payload.length - 4 : payload.length;
            if (payload[1] & 0x04) {
                // retrieval of the frame date timestamp value, then conversion to epoch 2013 (+1356998400), then in second
                const myDate = new Date((payload.readUInt32BE(payload.length - 4) + 1356998400) * 1000);
                // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
                appContent['timestamp'] = myDate.toJSON().replace('Z', '');
            }
            // Loop through historic data [t=0, t-1, t-2,...]
            for (let offset = 6; offset < payloadLength; offset += 2) {
                absCounterValue -= payload.readUInt16BE(offset);
                values.push(absCounterValue);
            }
            appContent['decodingInfo'] = 'counterValues: [t=0, t-1, t-2, ...]';
            appContent['counterValues'] = values;
            return appContent;
        }
        /**
         * Get reading frequency
         * @param configuration configuration
         */
        getReadingFrequency(configuration) {
            return configuration.byteLength > 0 ? configuration.readUInt16BE(8) * configuration.readUInt16BE(6) * 2 : null;
        }
    }
    codec.PulseV40x5bParser = PulseV40x5bParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Pulse V4 status byte parser
     */
    class PulseV4StatusByteParser {
        deviceType = 'pulse4';
        frameCode = 0;
        parseFrame(payload, configuration, network) {
            let statusContent = {};
            const parser = new codec.GenericStatusByteParser();
            statusContent = parser.parseFrame(payload, configuration);
            // Status byte, applicative flags
            statusContent['timestamp'] = Boolean(payload[1] & 0x04);
            return { status: statusContent };
        }
    }
    codec.PulseV4StatusByteParser = PulseV4StatusByteParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Pulse 4 0x10 (configuration) frame parser
     */
    class PulseV4NbIot0x10Parser {
        deviceType = 'pulse4nbiot';
        frameCode = 0x10;
        // Offset to add in order to jump NB-Iot additional header
        hOffset = 13;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x10 Pulse 4 NB-IoT configuration' };
            const chA = { name: 'channel A' };
            const chB = { name: 'channel B' };
            // Product mode
            appContent['productMode'] = codec.PlateformCommonUtils.getProductModeText(payload[this.hOffset + 2]);
            // Transmission period
            appContent['numberOfHistorizationBeforeSending'] = payload.readUInt16BE(this.hOffset + 3);
            appContent['samplingPeriod'] = { unit: 's', value: payload.readUInt16BE(this.hOffset + 6) * 2 };
            appContent['calculatedSendingPeriod'] = {
                unit: 's',
                value: payload.readUInt16BE(this.hOffset + 3) * payload.readUInt16BE(this.hOffset + 6) * 2,
            };
            // Flow calculation period
            if (payload[this.hOffset + 2] === 2) {
                // TEST mode => period = value * 20sec
                appContent['flowCalculationPeriod'] = { unit: 's', value: payload.readUInt16BE(this.hOffset + 9) * 20 };
            }
            else {
                // PRODUCTION mode => period = value * 1min
                appContent['flowCalculationPeriod'] = { unit: 'm', value: payload.readUInt16BE(this.hOffset + 9) };
            }
            appContent['redundantSamples'] = payload.readUInt8(this.hOffset + 27);
            // Channels A configuration
            chA['state'] = this.getStateText(Boolean(payload[this.hOffset + 5] & 0x01));
            chA['type'] = this.getTypeText(Boolean(payload[this.hOffset + 5] & 0x02));
            chA['debouncingPeriod'] = {
                unit: 'ms',
                value: this.getDebouncingPeriodText(payload[this.hOffset + 8] & 0x0f),
            };
            chA['leakageDetection'] = {
                overflowAlarmTriggerThreshold: payload.readUInt16BE(this.hOffset + 11),
                threshold: payload.readUInt16BE(this.hOffset + 15),
                dailyPeriodsBelowWhichLeakageAlarmTriggered: payload.readUInt16BE(this.hOffset + 19),
            };
            chA['tamper'] = {
                activated: Boolean(payload[this.hOffset + 5] & 0x08),
                samplePeriodForDetection: { unit: 's', value: payload.readUInt8(this.hOffset + 23) * 10 },
                threshold: payload.readUInt8(this.hOffset + 24),
            };
            // Channel B configuration
            chB['state'] = this.getStateText(Boolean(payload[this.hOffset + 5] & 0x10));
            chB['type'] = this.getTypeText(Boolean(payload[this.hOffset + 5] & 0x20));
            chB['debouncingPeriod'] = {
                unit: 'ms',
                value: this.getDebouncingPeriodText((payload[this.hOffset + 8] & 0xf0) >> 4),
            };
            chB['leakageDetection'] = {
                overflowAlarmTriggerThreshold: payload.readUInt16BE(this.hOffset + 13),
                threshold: payload.readUInt16BE(this.hOffset + 17),
                dailyPeriodsBelowWhichLeakageAlarmTriggered: payload.readUInt16BE(this.hOffset + 21),
            };
            chB['tamper'] = {
                activated: Boolean(payload[this.hOffset + 5] & 0x80),
                samplePeriodForDetection: { unit: 's', value: payload.readUInt8(this.hOffset + 25) * 10 },
                threshold: payload.readUInt8(this.hOffset + 26),
            };
            appContent['channels'] = [chA, chB];
            return appContent;
        }
        /**
         * Get state text
         * @param value value
         */
        getStateText(value) {
            return value ? 'enabled' : 'disabled';
        }
        /**
         * Get type text
         * @param value value
         */
        getTypeText(value) {
            return value ? 'gasPullUpOn' : 'otherPullUpOff';
        }
        /**
         * Get debouncing period text
         * @param value value
         */
        getDebouncingPeriodText(value) {
            switch (value) {
                case 0:
                    return 0;
                case 1:
                    return 1;
                case 2:
                    return 10;
                case 3:
                    return 20;
                case 4:
                    return 50;
                case 5:
                    return 100;
                case 6:
                    return 200;
                case 7:
                    return 500;
                case 8:
                    return 1000;
                case 9:
                    return 2000;
                case 10:
                    return 5000;
                case 11:
                    return 10000;
                default:
                    return 0;
            }
        }
    }
    codec.PulseV4NbIot0x10Parser = PulseV4NbIot0x10Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Generic 0x20 (configuration) frame parser
     */
    class PulseV4NbIot0x20Parser {
        deviceType = 'pulse4nbiot';
        frameCode = 0x20;
        // Offset to add in order to jump NB-Iot additional header
        hOffset = 13;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x20 Pulse 4 NB-IoT Configuration' };
            appContent['remoteServerIpAddress'] = this.payloadToString(payload, this.hOffset + 2, this.hOffset + 2 + 30);
            appContent['remoteServerPort'] = payload.readUInt16BE(this.hOffset + 33);
            appContent['localPort'] = payload.readUInt16BE(this.hOffset + 35);
            appContent['apn'] = this.payloadToString(payload, this.hOffset + 37, this.hOffset + 37 + 30);
            return appContent;
        }
        payloadToString(payload, start, end) {
            const charCode = [];
            for (let i = start; i < end; i++) {
                if (payload[i] !== 0x00) {
                    charCode.push(payload[i]);
                }
            }
            return String.fromCharCode(...charCode);
        }
    }
    codec.PulseV4NbIot0x20Parser = PulseV4NbIot0x20Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Pulse 4 0x30 (keep alive) frame parser
     */
    class PulseV4NbIot0x30Parser {
        deviceType = 'pulse4nbiot';
        frameCode = 0x30;
        // Offset to add in order to jump NB-Iot additional header
        hOffset = 13;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x30 Pulse 4 NB-IoT keep alive' };
            if (payload[this.hOffset + 1] & 0x04) {
                // retrieval of the frame date timestamp value, then conversion to epoch 2013 (+1356998400), then in second
                const myDate = new Date((payload.readUInt32BE(this.hOffset + 11) + 1356998400) * 1000);
                // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
                appContent['timestamp'] = myDate.toJSON().replace('Z', '');
            }
            const chA = { name: 'channel A' };
            const chB = { name: 'channel B' };
            chA['flow'] = {
                alarm: Boolean(payload[this.hOffset + 2] & 0x01),
                last24hMin: payload.readUInt16BE(this.hOffset + 7),
                last24hMax: payload.readUInt16BE(this.hOffset + 3),
            };
            chA['tamperAlarm'] = Boolean(payload[this.hOffset + 2] & 0x04);
            chA['leakageAlarm'] = Boolean(payload[this.hOffset + 2] & 0x10);
            chB['flow'] = {
                alarm: Boolean(payload[this.hOffset + 2] & 0x02),
                last24hMin: payload.readUInt16BE(this.hOffset + 9),
                last24hMax: payload.readUInt16BE(this.hOffset + 5),
            };
            chB['tamperAlarm'] = Boolean(payload[this.hOffset + 2] & 0x08);
            chB['leakageAlarm'] = Boolean(payload[this.hOffset + 2] & 0x20);
            appContent['channels'] = [chA, chB];
            return appContent;
        }
    }
    codec.PulseV4NbIot0x30Parser = PulseV4NbIot0x30Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Generic 0x33 (Response to Set Register downlink) frame parser
     */
    class PulseV4NbIot0x33Parser {
        deviceType = 'pulse4nbiot';
        frameCode = 0x33;
        // Offset to add in order to jump NB-Iot additional header
        hOffset = 13;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x33 Set register status' };
            appContent['requestStatus'] = this.getRequestStatusText(payload[this.hOffset + 2]);
            appContent['registerId'] = payload.readUInt16BE(this.hOffset + 3);
            return appContent;
        }
        /**
         * Get Type text
         * @param value value
         */
        getRequestStatusText(value) {
            switch (value) {
                case 1:
                    return 'success';
                case 2:
                    return 'successNoUpdate';
                case 3:
                    return 'errorCoherency';
                case 4:
                    return 'errorInvalidRegister';
                case 5:
                    return 'errorInvalidValue';
                case 6:
                    return 'errorTruncatedValue';
                case 7:
                    return 'errorAccesNotAllowed';
                default:
                    return 'errorOtherReason';
            }
        }
    }
    codec.PulseV4NbIot0x33Parser = PulseV4NbIot0x33Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Pulse 4 0x46 (data) frame parser
     */
    class PulseV4NbIot0x46Parser {
        deviceType = 'pulse4nbiot';
        frameCode = 0x46;
        // Offset to add in order to jump NB-Iot additional header
        hOffset = 13;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x46 Pulse 4 NB-IoT data' };
            if (payload[this.hOffset + 1] & 0x04) {
                // retrieval of the frame date timestamp value, then conversion to epoch 2013 (+1356998400), then in second
                const myDate = new Date((payload.readUInt32BE(this.hOffset + 10) + 1356998400) * 1000);
                // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
                appContent['timestamp'] = myDate.toJSON().replace('Z', '');
            }
            appContent['decodingInfo'] = 'counterValues: [Channel A, Channel B]';
            // Current indexes [Channel A, Channel B]
            appContent['counterValues'] = [payload.readUInt32BE(this.hOffset + 2), payload.readUInt32BE(this.hOffset + 6)];
            return appContent;
        }
    }
    codec.PulseV4NbIot0x46Parser = PulseV4NbIot0x46Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Pulse 4 0x47 (alarm) frame parser
     */
    class PulseV4NbIot0x47Parser {
        deviceType = 'pulse4nbiot';
        frameCode = 0x47;
        // Offset to add in order to jump NB-Iot additional header
        hOffset = 13;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x47 Pulse 4 NB-IoT alarm' };
            if (payload[this.hOffset + 1] & 0x04) {
                // retrieval of the frame date timestamp value, then conversion to epoch 2013 (+1356998400), then in second
                const myDate = new Date((payload.readUInt32BE(this.hOffset + 6) + 1356998400) * 1000);
                // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
                appContent['timestamp'] = myDate.toJSON().replace('Z', '');
            }
            appContent['decodingInfo'] = 'flowValues: [Channel A, Channel B]';
            // Flows when overflow occured [Channel A, Channel B]
            appContent['flowValues'] = [payload.readUInt16BE(this.hOffset + 2), payload.readUInt16BE(this.hOffset + 4)];
            return appContent;
        }
    }
    codec.PulseV4NbIot0x47Parser = PulseV4NbIot0x47Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Pulse 4 periodic data  frame parser
     */
    class PulseV4NbIot0x5aParser {
        deviceType = 'pulse4nbiot';
        frameCode = 0x5a;
        // Offset to add in order to jump NB-Iot additional header
        hOffset = 13;
        parseFrame(payload, configuration, network) {
            let absCounterValue = payload.readUInt32BE(this.hOffset + 2);
            const appContent = { type: '0x5a Pulse 4 NB-IoT data - channel A' };
            const values = [absCounterValue];
            const payloadLength = payload[this.hOffset + 1] & 0x04 ? payload.length - 4 : payload.length;
            if (payload[this.hOffset + 1] & 0x04) {
                // retrieval of the frame date timestamp value, then conversion to epoch 2013 (+1356998400), then in second
                const myDate = new Date((payload.readUInt32BE(payload.length - 4) + 1356998400) * 1000);
                // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
                appContent['timestamp'] = myDate.toJSON().replace('Z', '');
            }
            // Loop through historic data [t=0, t-1, t-2,...]
            for (let offset = this.hOffset + 6; offset < payloadLength; offset += 2) {
                absCounterValue -= payload.readUInt16BE(offset);
                values.push(absCounterValue);
            }
            appContent['decodingInfo'] = 'counterValues: [t=0, t-1, t-2, ...]';
            appContent['counterValues'] = values;
            return appContent;
        }
        /**
         * Get reading frequency
         * @param configuration configuration
         */
        getReadingFrequency(configuration) {
            return configuration.byteLength > 0 ? configuration.readUInt16BE(8) * configuration.readUInt16BE(6) * 2 : null;
        }
    }
    codec.PulseV4NbIot0x5aParser = PulseV4NbIot0x5aParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Pulse 4 periodic data frame parser
     */
    class PulseV4NbIot0x5bParser {
        deviceType = 'pulse4nbiot';
        frameCode = 0x5b;
        // Offset to add in order to jump NB-Iot additional header
        hOffset = 13;
        parseFrame(payload, configuration, network) {
            let absCounterValue = payload.readUInt32BE(this.hOffset + 2);
            const appContent = { type: '0x5b Pulse 4 NB-IoT data - channel B' };
            const values = [absCounterValue];
            const payloadLength = payload[this.hOffset + 1] & 0x04 ? payload.length - 4 : payload.length;
            if (payload[this.hOffset + 1] & 0x04) {
                // retrieval of the frame date timestamp value, then conversion to epoch 2013 (+1356998400), then in second
                const myDate = new Date((payload.readUInt32BE(payload.length - 4) + 1356998400) * 1000);
                // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
                appContent['timestamp'] = myDate.toJSON().replace('Z', '');
            }
            // Loop through historic data [t=0, t-1, t-2,...]
            for (let offset = this.hOffset + 6; offset < payloadLength; offset += 2) {
                absCounterValue -= payload.readUInt16BE(offset);
                values.push(absCounterValue);
            }
            appContent['decodingInfo'] = 'counterValues: [t=0, t-1, t-2, ...]';
            appContent['counterValues'] = values;
            return appContent;
        }
        /**
         * Get reading frequency
         * @param configuration configuration
         */
        getReadingFrequency(configuration) {
            return configuration.byteLength > 0 ? configuration.readUInt16BE(8) * configuration.readUInt16BE(6) * 2 : null;
        }
    }
    codec.PulseV4NbIot0x5bParser = PulseV4NbIot0x5bParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Pulse V4 status byte parser
     */
    class PulseV4NbIotStatusByteParser {
        deviceType = 'pulse4nbiot';
        frameCode = 0;
        // Offset to add in order to jump NB-Iot additional header
        hOffset = 13;
        parseFrame(payload, configuration, network) {
            const headerContent = {};
            const statusContent = {};
            // Include in status byte parser also NB-IoT header (13 bytes length):
            // 0-7	IMEI	International Mobile Equipment Identity (IMEI) of the product (15 digits in BCD format).
            // 8	Radio Signal quality	Value from 0 to 5.
            // 9-12	Frame counter	Frame counter since product reset.
            headerContent['imei'] = payload.readUInt32BE(0).toString(16) + payload.readUInt32BE(4).toString(16);
            headerContent['signalQuality'] = payload[8];
            headerContent['globalFrameCounter'] = payload.readUInt32BE(9);
            // Status byte, applicative flags
            statusContent['frameCounter'] = (payload[this.hOffset + 1] & 0xe0) >> 5;
            statusContent['lowBattery'] = Boolean(payload[this.hOffset + 1] & 0x02);
            statusContent['configurationDone'] = Boolean(payload[this.hOffset + 1] & 0x01);
            statusContent['timestamp'] = Boolean(payload[this.hOffset + 1] & 0x04);
            return { nbIot: headerContent, status: statusContent };
        }
    }
    codec.PulseV4NbIotStatusByteParser = PulseV4NbIotStatusByteParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    class Repeater0x01InputData {
        // Accepted values are:
        // 0 retour en mode PARK
        // 1 retour en mode installation auto
        // 2 retour en mode opération, WL vide, rafraichissement de la WL à chaque trame OoB
        return_mode = 0;
    }
    codec.Repeater0x01InputData = Repeater0x01InputData;
    /**
     * Repeater 0x01 frame builder
     */
    class Repeater0x01Builder {
        deviceType = 'repeater';
        frameCode = 0x01;
        inputDataClass = Repeater0x01InputData;
        buildFrame(inputData, network) {
            const payload = Buffer.alloc(8);
            payload[0] = this.frameCode;
            payload.writeUInt8(inputData.return_mode, 1);
            return payload;
        }
    }
    codec.Repeater0x01Builder = Repeater0x01Builder;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Repeater 0x01 frame parser
     */
    class Repeater0x01Parser {
        deviceType = 'repeater';
        frameCode = 0x01;
        parseFrame(payload, configuration, network) {
            const appContent = {
                type: '0x01 Repeater WL add',
                ...this.getDataFromPayload(payload),
            };
            return appContent;
        }
        getDataFromPayload(payload) {
            const appContent = {};
            codec.RepeaterHelper.getUPStatusFromPayload(payload, appContent);
            return appContent;
        }
    }
    codec.Repeater0x01Parser = Repeater0x01Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    class Repeater0x02InputData {
        // wl_activation accepted values are 0x00 or 0x01
        wl_activation = 0x00;
        id = 0;
    }
    codec.Repeater0x02InputData = Repeater0x02InputData;
    /**
     * Repeater 0x02 frame builder
     */
    class Repeater0x02Builder {
        deviceType = 'repeater';
        frameCode = 0x02;
        inputDataClass = Repeater0x02InputData;
        buildFrame(inputData, network) {
            const payload = Buffer.alloc(8);
            payload[0] = this.frameCode;
            payload.writeUInt8(inputData.wl_activation, 1);
            payload.writeUInt32BE(inputData.id, 1);
            return payload;
        }
    }
    codec.Repeater0x02Builder = Repeater0x02Builder;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Repeater 0x02 frame parser
     */
    class Repeater0x02Parser {
        deviceType = 'repeater';
        frameCode = 0x02;
        parseFrame(payload, configuration, network) {
            const appContent = {
                type: '0x02 Repeater WL modification',
                ...this.getDataFromPayload(payload),
            };
            return appContent;
        }
        getDataFromPayload(payload) {
            const appContent = {};
            codec.RepeaterHelper.getUPStatusFromPayload(payload, appContent);
            appContent['numberOfIdInWl'] = payload.readUInt8(2);
            return appContent;
        }
    }
    codec.Repeater0x02Parser = Repeater0x02Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    class Repeater0x03InputData {
        // wl_validation accepted values are 0x00 or 0x01
        wl_validation = 0x00;
        id = 0;
    }
    codec.Repeater0x03InputData = Repeater0x03InputData;
    /**
     * Repeater 0x03 frame builder
     */
    class Repeater0x03Builder {
        deviceType = 'repeater';
        frameCode = 0x03;
        inputDataClass = Repeater0x03InputData;
        buildFrame(inputData, network) {
            const payload = Buffer.alloc(8);
            payload[0] = this.frameCode;
            payload.writeUInt8(inputData.wl_validation, 1);
            payload.writeUInt32BE(inputData.id, 2);
            return payload;
        }
    }
    codec.Repeater0x03Builder = Repeater0x03Builder;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Repeater 0x02 frame parser
     */
    class Repeater0x03Parser {
        deviceType = 'repeater';
        frameCode = 0x03;
        parseFrame(payload, configuration, network) {
            const appContent = {
                type: '0x03 Repeater DL confirmation',
                ...this.getDataFromPayload(payload),
            };
            return appContent;
        }
        getDataFromPayload(payload) {
            const appContent = {};
            codec.RepeaterHelper.getUPStatusFromPayload(payload, appContent);
            appContent['downlinkCode'] = codec.RepeaterHelper.getDownlinkDescriptionForCode(payload.readUInt8(2));
            appContent['downlinkErrorCode'] = codec.RepeaterHelper.getErrorDescriptionForCode(payload.readUInt8(3));
            return appContent;
        }
    }
    codec.Repeater0x03Parser = Repeater0x03Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    class Repeater0x04InputData {
        S300 = 1; // 01- 31
        S303 = 0; // 00 ou 02
        S304 = 0; // 00/01/02
        S306 = 0; // 00 ou 02
    }
    codec.Repeater0x04InputData = Repeater0x04InputData;
    /**
     * Repeater 0x04 frame builder
     */
    class Repeater0x04Builder {
        deviceType = 'repeater';
        frameCode = 0x04;
        inputDataClass = Repeater0x04InputData;
        buildFrame(inputData, network) {
            const payload = Buffer.alloc(8);
            payload[0] = this.frameCode;
            payload.writeUInt8(inputData.S300, 1);
            payload.writeUInt8(inputData.S303, 2);
            payload.writeUInt8(inputData.S304, 3);
            payload.writeUInt8(inputData.S306, 4);
            return payload;
        }
        getFirstIds(ids) {
            return ids.filter(id => id >= 8);
        }
        getLastIds(ids) {
            return ids.filter(id => id < 8);
        }
        getByteFromIdsList(ids) {
            const intArray = Buffer.alloc(8);
            ids.forEach((id, idx) => (intArray[idx] = id));
            return intArray.readUInt8(0);
        }
    }
    codec.Repeater0x04Builder = Repeater0x04Builder;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Repeater 0x04 frame parser
     */
    class Repeater0x04Parser {
        deviceType = 'repeater';
        frameCode = 0x04;
        parseFrame(payload, configuration, network) {
            const appContent = {
                type: '0x04 White List confirmation',
                ...this.getDataFromPayload(payload),
            };
            return appContent;
        }
        getDataFromPayload(payload) {
            const appContent = {};
            codec.RepeaterHelper.getUPStatusFromPayload(payload, appContent);
            appContent['numberOfIdInWl'] = payload.readUInt8(2);
            return appContent;
        }
    }
    codec.Repeater0x04Parser = Repeater0x04Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    class Repeater0x05InputData {
    }
    codec.Repeater0x05InputData = Repeater0x05InputData;
    /**
     * Repeater 0x05 frame builder
     */
    class Repeater0x05Builder {
        deviceType = 'repeater';
        frameCode = 0x05;
        inputDataClass = Repeater0x05InputData;
        buildFrame(inputData, network) {
            const payload = Buffer.alloc(8);
            payload[0] = this.frameCode;
            return payload;
        }
    }
    codec.Repeater0x05Builder = Repeater0x05Builder;
})(codec || (codec = {}));
var codec;
(function (codec) {
    const errorCode = {
        0x00: '0x00 The action has been correctly realized',
        0x0a: '0x0A Uplink code is invalid',
        0x0b: '0x0B Harware error, please contact adeunis support',
        0x0c: '0x0C Callback error',
        0x0d: '0x0D Generic error',
        0x01: '0x01 White List already empty',
        0x02: '0x02 White List not erased',
        0x03: '0x03 White List is empty, repeater switch into OPERATION with “auto-record” mode',
        0x04: '0x04 ID not found in the White List',
        0x05: '0x05 White List is full, “add an ID” not possible',
        0x06: '0x06 ID already existing in the White List',
        0x07: '0x07 No ID repeated, repeater stay into OPERATION with “auto-record” mode',
        0x08: '0x08 A White List is already existing, use “Suppress all IDs from White List” frame before',
        0x11: '0x11 Error with S300 configuration',
        0x12: '0x12 Error with S303 configuration',
        0x13: '0x13 Error with S300, S303 configuration',
        0x14: '0x14 Error with S304 configuration',
        0x15: '0x15 Error with S300, S304 configuration',
        0x16: '0x16 Error with S303, S304 configuration',
        0x17: '0x17 Error with S300, S303, S304 configuration',
        0x18: '0x18 Error with S306 configuration',
        0x19: '0x19 Error with S300, S306 configuration',
        0x1a: '0x1A Error with S303, S306 configuration',
        0x1b: '0x1B Error with S300, S303, S306 configuration',
        0x1c: '0x1C Error with S304, S306 configuration',
        0x1d: '0x1D Error with S300, S304, S306 configuration',
        0x1e: '0x1E Error with S303, S304, S306 configuration',
        0x1f: '0x1F Error with S300, S303, S304, S306 configuration',
    };
    const dlCode = {
        0x01: '0x01 Suppress all IDs from White List',
        0x02: '0x02 Delete an ID from White List',
        0x03: '0x03 Add an ID into White List',
        0x05: '0x05 Freeze the list of devices repeated in auto-record mode into the White List',
        0x04: '0x04 Modify Repeater configuration',
    };
    class RepeaterHelper {
        static hex2bin(hex) {
            return parseInt(hex, 16).toString(2).padStart(8, '0');
        }
        static getUPStatusFromPayload(payload, appContent) {
            const byte = payload[1];
            let charLb = 1;
            if (/^\d$/.test('' + byte)) {
                // one digit
                appContent['frameCounter'] = 0;
                charLb = 0;
            }
            else {
                appContent['frameCounter'] = parseInt(payload.readUInt8(1).toString(16).charAt(0), 16);
            }
            const hexLb = payload.readUInt8(1).toString(16);
            const binLb = RepeaterHelper.hex2bin(hexLb);
            const bitLb = binLb[binLb.length - 1];
            appContent['lowBattery'] = bitLb === '1' ? true : false;
            return appContent;
        }
        static getDownlinkDescriptionForCode(code) {
            return dlCode[code] || code;
        }
        static getErrorDescriptionForCode(code) {
            return errorCode[code] || code;
        }
    }
    codec.RepeaterHelper = RepeaterHelper;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Extended status byte parser
     */
    class RepeaterStatusByteParser {
        deviceType = 'repeater';
        frameCode = 0;
        parseFrame(payload, configuration) {
            // Skip generic status byte parser
            return {};
        }
    }
    codec.RepeaterStatusByteParser = RepeaterStatusByteParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Temperature 0x10 (configuration) frame parser
     */
    class Temp0x10Parser {
        deviceType = 'temp';
        frameCode = 0x10;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x10 Temperature configuration' };
            const temp1 = { name: 'probe 1' };
            const temp2 = { name: 'probe 2' };
            if (payload[8] === 2) {
                // TEST mode => period = value * 20sec
                appContent['transmissionPeriodKeepAlive'] = { unit: 's', value: payload[2] * 20 };
                appContent['transmissionPeriodData'] = { unit: 's', value: payload[3] * 20 };
                appContent['samplingPeriod'] = { unit: 's', value: payload[10] * 10 };
            }
            else {
                // PRODUCTION mode => period = value * 10min
                appContent['transmissionPeriodKeepAlive'] = { unit: 'm', value: payload[2] * 10 };
                appContent['transmissionPeriodData'] = { unit: 'm', value: payload[3] * 10 };
                appContent['samplingPeriod'] = { unit: 'm', value: payload[10] };
            }
            // Internal sensor input states
            temp1['id'] = (payload[4] & 0xf0) >> 4;
            temp1['threshold'] = this.getThresholdTriggeringText(payload[5] & 0x03);
            // Concerns only FW >= 1.3.8
            temp1['state'] = payload[9] & 0x01 ? 'activated' : 'deactivated';
            // External sensor input states
            temp2['id'] = (payload[6] & 0xf0) >> 4;
            temp2['threshold'] = this.getThresholdTriggeringText(payload[7] & 0x03);
            // Concerns only FW >= 1.3.8
            temp2['state'] = payload[9] & 0x02 ? 'activated' : 'deactivated';
            appContent['probes'] = [temp1, temp2];
            // Product mode
            appContent['productMode'] = codec.PlateformCommonUtils.getProductModeText(payload[8]);
            return appContent;
        }
        /**
         * Get Threshold Triggering text
         * @param value value
         */
        getThresholdTriggeringText(value) {
            switch (value) {
                case 0:
                    return 'none';
                case 1:
                    return 'low';
                case 2:
                    return 'high';
                case 3:
                    return 'both';
                default:
                    return '';
            }
        }
    }
    codec.Temp0x10Parser = Temp0x10Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Temperature 0x11 (configuration) frame parser
     */
    class Temp0x11Parser {
        deviceType = 'temp';
        frameCode = 0x11;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x11 Temperature configuration' };
            // Internal sensor high threshold configuration
            appContent['threshold'] = {
                name: 'probe 1',
                unit: '\u00B0' + 'C',
                high: {
                    value: payload.readInt16BE(2) / 10,
                    hysteresis: payload[4] / 10,
                },
                low: {
                    value: payload.readInt16BE(5) / 10,
                    hysteresis: payload[7] / 10,
                },
            };
            appContent['superSamplingFactor'] = payload[8];
            return appContent;
        }
    }
    codec.Temp0x11Parser = Temp0x11Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Temperature 0x12 (configuration) frame parser
     */
    class Temp0x12Parser {
        deviceType = 'temp';
        frameCode = 0x12;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x12 Temperature configuration' };
            appContent['threshold'] = {
                name: 'probe 2',
                unit: '\u00B0' + 'C',
                high: {
                    value: payload.readInt16BE(2) / 10,
                    hysteresis: payload[4] / 10,
                },
                low: {
                    value: payload.readInt16BE(5) / 10,
                    hysteresis: payload[7] / 10,
                },
            };
            return appContent;
        }
    }
    codec.Temp0x12Parser = Temp0x12Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Temperature 0x30 (keep alive) frame parser
     */
    class Temp0x30Parser {
        deviceType = 'temp';
        frameCode = 0x30;
        temp0x43Parser = new codec.Temp0x43Parser();
        parseFrame(payload, configuration, network) {
            const appContent = this.temp0x43Parser.parseFrame(payload, configuration, network);
            appContent['type'] = '0x30 Temperature keep alive';
            return appContent;
        }
    }
    codec.Temp0x30Parser = Temp0x30Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Temperature 0x43 (data) frame parser
     */
    class Temp0x43Parser {
        deviceType = 'temp';
        frameCode = 0x43;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x43 Temperature data' };
            const temp1 = { name: 'probe 1' };
            const temp2 = { name: 'probe 2' };
            // Internal sensor input states
            temp1['id'] = (payload[2] & 0xf0) >> 4;
            temp1['unit'] = '\u00B0' + 'C';
            // value@-3276.8 must be considered as an invalid measure (probe disconnected for instance)
            temp1['value'] = payload.readInt16BE(3) / 10;
            // External sensor input states
            temp2['id'] = (payload[5] & 0xf0) >> 4;
            temp2['unit'] = '\u00B0' + 'C';
            // value@-3276.8 must be considered as an invalid measure (probe disconnected for instance)
            temp2['value'] = payload.readInt16BE(6) / 10;
            // With FW > 1.3.8 we are able to activate or not a probe : detect these FW thanks to a specific value
            // sent by old FW
            if ((payload[5] & 0x0f) !== 2) {
                temp1['state'] = payload[2] & 0x01 ? 'activated' : 'deactivated';
                temp2['state'] = payload[5] & 0x01 ? 'activated' : 'deactivated';
            }
            appContent['temperatures'] = [temp1, temp2];
            return appContent;
        }
    }
    codec.Temp0x43Parser = Temp0x43Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Temperature status byte parser
     */
    class TempStatusByteParser {
        deviceType = 'temp';
        frameCode = 0;
        parseFrame(payload, configuration, network) {
            let statusContent = {};
            const parser = new codec.GenericStatusByteParser();
            statusContent = parser.parseFrame(payload, configuration);
            // Status byte, applicative flags
            statusContent['probe1Alarm'] = Boolean(payload[1] & 0x08);
            statusContent['probe2Alarm'] = Boolean(payload[1] & 0x10);
            return { status: statusContent };
        }
    }
    codec.TempStatusByteParser = TempStatusByteParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Temp 3 0x10 (configuration) frame parser
     */
    class TempV30x10Parser {
        deviceType = 'temp3';
        frameCode = 0x10;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x10 Temp 3 configuration' };
            (appContent['transmissionPeriodKeepAlive'] = { unit: 's', value: payload.readUInt16BE(2) * 10 }),
                (appContent['numberOfHistorizationBeforeSending'] = payload.readUInt16BE(4)),
                (appContent['numberOfSamplingBeforeHistorization'] = payload.readUInt16BE(6)),
                (appContent['samplingPeriod'] = { unit: 's', value: payload.readUInt16BE(8) * 2 }),
                (appContent['redundantSamples'] = payload.readUInt8(10)),
                (appContent['calculatedPeriodRecording'] = {
                    unit: 's',
                    value: payload.readUInt16BE(8) * payload.readUInt16BE(6) * 2,
                }),
                (appContent['calculatedSendingPeriod'] = {
                    unit: 's',
                    value: payload.readUInt16BE(8) * payload.readUInt16BE(6) * payload.readUInt16BE(4) * 2,
                });
            return appContent;
        }
    }
    codec.TempV30x10Parser = TempV30x10Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Temp 3 0x30 (keep alive) frame parser
     */
    class TempV30x30Parser {
        deviceType = 'temp3';
        frameCode = 0x30;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x30 Temp 3 keep alive' };
            const nbSensors = payload[1] & 0x10 ? 2 : 1;
            const temperatures = [];
            // value@-3276.8 must be considered as an invalid measure (probe disconnected for instance)
            temperatures['push']({ name: 'temperature 1', unit: '\u00B0' + 'C', value: payload.readInt16BE(2) / 10 });
            if (nbSensors === 2) {
                temperatures['push']({ name: 'temperature 2', unit: '\u00B0' + 'C', value: payload.readInt16BE(4) / 10 });
            }
            appContent['temperatures'] = temperatures;
            return appContent;
        }
    }
    codec.TempV30x30Parser = TempV30x30Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Temp 3 0x57 (data) frame parser
     */
    class TempV30x57Parser {
        deviceType = 'temp3';
        frameCode = 0x57;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x57 Temp 3 periodic data' };
            const nbSensors = payload[1] & 0x10 ? 2 : 1;
            let rawValue;
            const temperatures = [];
            const ch1Temp = [], ch2Temp = [];
            // Loop through historic data [t=0, t-1, t-2,...]
            // value@-3276.8 must be considered as an invalid measure (probe disconnected for instance)
            for (let offset = 2; offset < payload.length; offset += 2 * nbSensors) {
                rawValue = payload.readInt16BE(offset);
                ch1Temp.push(rawValue / 10);
                if (nbSensors === 2) {
                    rawValue = payload.readInt16BE(offset + 2);
                    ch2Temp.push(rawValue / 10);
                }
            }
            appContent['decodingInfo'] = 'values: [t=0, t-1, t-2, ...]';
            // value@-3276.8 must be considered as an invalid measure (probe disconnected for instance)
            temperatures['push']({ name: 'temperature 1', unit: '\u00B0' + 'C', values: ch1Temp });
            if (nbSensors === 2) {
                temperatures['push']({ name: 'temperature 2', unit: '\u00B0' + 'C', values: ch2Temp });
            }
            appContent['temperatures'] = temperatures;
            return appContent;
        }
    }
    codec.TempV30x57Parser = TempV30x57Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Temp 3 0x58 (alarm) frame parser
     */
    class TempV30x58Parser {
        deviceType = 'temp3';
        frameCode = 0x58;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x58 Temp 3 alarm' };
            const alarms = [];
            const nbSensors = payload[1] & 0x10 ? 2 : 1;
            alarms['push']({
                name: 'temperature 1',
                alarmStatus: this.getAlarmStatusText(payload.readUInt8(2)),
                temperature: { unit: '\u00B0' + 'C', value: payload.readInt16BE(3) / 10 },
            });
            if (nbSensors === 2) {
                alarms['push']({
                    name: 'temperature 2',
                    alarmStatus: this.getAlarmStatusText(payload.readUInt8(5)),
                    temperature: { unit: '\u00B0' + 'C', value: payload.readInt16BE(6) / 10 },
                });
            }
            appContent['alarms'] = alarms;
            return appContent;
        }
        /**
         * Get Alarm status text
         * @param value value
         */
        getAlarmStatusText(value) {
            switch (value) {
                case 1:
                    return 'highThreshold';
                case 2:
                    return 'lowThreshold';
                default:
                    return 'none';
            }
        }
    }
    codec.TempV30x58Parser = TempV30x58Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Temp 3 status byte parser
     */
    class TempV3StatusByteParser {
        deviceType = 'temp3';
        frameCode = 0;
        parseFrame(payload, configuration, network) {
            let statusContent = {};
            const parser = new codec.GenericStatusByteParser();
            statusContent = parser.parseFrame(payload, configuration);
            // Status byte, applicative flags
            statusContent['configurationInconsistency'] = Boolean(payload[1] & 0x08);
            statusContent['configuration2ChannelsActivated'] = Boolean(payload[1] & 0x10);
            return { status: statusContent };
        }
    }
    codec.TempV3StatusByteParser = TempV3StatusByteParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Temp 4 0x10 (configuration) frame parser
     */
    class TempV40x10Parser {
        deviceType = 'temp4';
        frameCode = 0x10;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x10 Temp 4 configuration' };
            (appContent['transmissionPeriodKeepAlive'] = { unit: 's', value: payload.readUInt16BE(2) * 10 }),
                (appContent['numberOfHistorizationBeforeSending'] = payload.readUInt16BE(4)),
                (appContent['numberOfSamplingBeforeHistorization'] = payload.readUInt16BE(6)),
                (appContent['samplingPeriod'] = { unit: 's', value: payload.readUInt16BE(8) * 2 }),
                (appContent['redundantSamples'] = payload.readUInt8(10)),
                (appContent['calculatedPeriodRecording'] = {
                    unit: 's',
                    value: payload.readUInt16BE(8) * payload.readUInt16BE(6) * 2,
                }),
                (appContent['calculatedSendingPeriod'] = {
                    unit: 's',
                    value: payload.readUInt16BE(8) * payload.readUInt16BE(6) * payload.readUInt16BE(4) * 2,
                });
            return appContent;
        }
    }
    codec.TempV40x10Parser = TempV40x10Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Temp 4 0x30 (keep alive) frame parser
     */
    class TempV40x30Parser {
        deviceType = 'temp4';
        frameCode = 0x30;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x30 Temp 4 keep alive' };
            const nbSensors = payload[1] & 0x10 ? 2 : 1;
            if (payload[1] & 0x04) {
                // offsetType for date timestamp position
                const offsetType = nbSensors === 2 ? 6 : 4;
                // retrieval of the frame date timestamp value, then conversion to epoch 2013 (+1356998400), then in second
                const myDate = new Date((payload.readUInt32BE(offsetType) + 1356998400) * 1000);
                // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
                appContent['timestamp'] = myDate.toJSON().replace('Z', '');
            }
            const temperatures = [];
            // value@-3276.8 must be considered as an invalid measure (probe disconnected for instance)
            temperatures['push']({ name: 'temperature 1', unit: '\u00B0' + 'C', value: payload.readInt16BE(2) / 10 });
            if (nbSensors === 2) {
                temperatures['push']({ name: 'temperature 2', unit: '\u00B0' + 'C', value: payload.readInt16BE(4) / 10 });
            }
            appContent['temperatures'] = temperatures;
            return appContent;
        }
    }
    codec.TempV40x30Parser = TempV40x30Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Temp 4 0x57 (data) frame parser
     */
    class TempV40x57Parser {
        deviceType = 'temp4';
        frameCode = 0x57;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x57 Temp 4 periodic data' };
            const nbSensors = payload[1] & 0x10 ? 2 : 1;
            let rawValue;
            const temperatures = [];
            const ch1Temp = [], ch2Temp = [];
            const payloadLength = payload[1] & 0x04 ? payload.length - 4 : payload.length;
            // if the timestamp flag is true or false
            // if (payload[1] & 0x04) {
            // Loop through historic data [t=0, t-1, t-2,...]
            // value@-3276.8 must be considered as an invalid measure (probe disconnected for instance)
            // we subtract 4 bytes from the total length of the frame to deduce the timestamp
            for (let offset = 2; offset < payloadLength; offset += 2 * nbSensors) {
                rawValue = payload.readInt16BE(offset);
                ch1Temp.push(rawValue / 10);
                if (nbSensors === 2) {
                    rawValue = payload.readInt16BE(offset + 2);
                    ch2Temp.push(rawValue / 10);
                }
            }
            if (payload[1] & 0x04) {
                // retrieval of the frame date timestamp value, then conversion to epoch 2013 (+1356998400), then in second
                const myDate = new Date((payload.readUInt32BE(payload.length - 4) + 1356998400) * 1000);
                // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
                appContent['timestamp'] = myDate.toJSON().replace('Z', '');
            }
            appContent['decodingInfo'] = 'values: [t=0, t-1, t-2, ...]';
            // value@-3276.8 must be considered as an invalid measure (probe disconnected for instance)
            temperatures['push']({ name: 'temperature 1', unit: '\u00B0' + 'C', values: ch1Temp });
            if (nbSensors === 2) {
                temperatures['push']({ name: 'temperature 2', unit: '\u00B0' + 'C', values: ch2Temp });
            }
            appContent['temperatures'] = temperatures;
            return appContent;
        }
    }
    codec.TempV40x57Parser = TempV40x57Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Temp 4 0x58 (alarm) frame parser
     */
    class TempV40x58Parser {
        deviceType = 'temp4';
        frameCode = 0x58;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x58 Temp 4 alarm' };
            const alarms = [];
            const nbSensors = payload[1] & 0x10 ? 2 : 1;
            // offsetType for date timestamp position
            const offsetType = nbSensors === 2 ? 8 : 5;
            alarms['push']({
                name: 'temperature 1',
                alarmStatus: this.getAlarmStatusText(payload.readUInt8(2)),
                temperature: { unit: '\u00B0' + 'C', value: payload.readInt16BE(3) / 10 },
            });
            if (nbSensors === 2) {
                alarms['push']({
                    name: 'temperature 2',
                    alarmStatus: this.getAlarmStatusText(payload.readUInt8(5)),
                    temperature: { unit: '\u00B0' + 'C', value: payload.readInt16BE(6) / 10 },
                });
            }
            if (payload[1] & 0x04) {
                // retrieval of the frame date timestamp value, then conversion to epoch 2013 (+1356998400), then in second
                const myDate = new Date((payload.readUInt32BE(offsetType) + 1356998400) * 1000);
                // As we do not know if timestamp is locale or UTC , do remove 'UTC' indication
                appContent['timestamp'] = myDate.toJSON().replace('Z', '');
            }
            appContent['alarms'] = alarms;
            return appContent;
        }
        /**
         * Get Alarm status text
         * @param value value
         */
        getAlarmStatusText(value) {
            switch (value) {
                case 1:
                    return 'highThreshold';
                case 2:
                    return 'lowThreshold';
                default:
                    return 'none';
            }
        }
    }
    codec.TempV40x58Parser = TempV40x58Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Temp 4 status byte parser
     */
    class TempV4StatusByteParser {
        deviceType = 'temp4';
        frameCode = 0;
        parseFrame(payload, configuration, network) {
            let statusContent = {};
            const parser = new codec.GenericStatusByteParser();
            statusContent = parser.parseFrame(payload, configuration);
            // Status byte, applicative flags
            statusContent['configurationInconsistency'] = Boolean(payload[1] & 0x08);
            statusContent['configuration2ChannelsActivated'] = Boolean(payload[1] & 0x10);
            statusContent['timestamp'] = Boolean(payload[1] & 0x04);
            return { status: statusContent };
        }
    }
    codec.TempV4StatusByteParser = TempV4StatusByteParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Tic 0x10 (configuration) frame parser
     */
    class Tic0x10Parser {
        deviceType = 'ticPmePmi|ticCbeLinkyMono|ticCbeLinkyTri';
        frameCode = 0x10;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x10 TIC configuration' };
            if (payload[5] === 2) {
                // TEST mode => period = value * 20sec
                appContent['transmissionPeriodKeepAlive'] = { unit: 's', value: payload[2] * 20 };
                appContent['samplingPeriod'] = { unit: 's', value: payload.readUInt16BE(6) * 20 };
            }
            else {
                // PRODUCTION mode => period = value * 10min
                appContent['transmissionPeriodKeepAlive'] = { unit: 'm', value: payload[2] * 10 };
                appContent['samplingPeriod'] = { unit: 'm', value: payload.readUInt16BE(6) };
            }
            appContent['transmissionPeriodData'] = payload.readUInt16BE(3);
            // Product mode
            appContent['productMode'] = codec.PlateformCommonUtils.getProductModeText(payload[5]);
            return appContent;
        }
    }
    codec.Tic0x10Parser = Tic0x10Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * TIC 0x49 (data) frame parser
     */
    class Tic0x49Parser {
        deviceType = 'ticPmePmi|ticCbeLinkyMono|ticCbeLinkyTri';
        frameCode = 0x49;
        parseFrame(payload, configuration, network, deviceType) {
            let appContent = { type: '0x49 TIC data' };
            if (deviceType === 'ticCbeLinkyMono') {
                appContent = this.payloadToString(payload, 2, 2 + 12, appContent, 'ADCO');
                appContent = this.payloadToString(payload, 14, 14 + 4, appContent, 'OPTARIF');
                appContent = this.payloadToValue(payload, 18, 'Wh', appContent, 'BASE');
                appContent = this.payloadToValue(payload, 22, 'A', appContent, 'ISOUSC');
                appContent = this.payloadToValue(payload, 26, 'A', appContent, 'IINST');
                appContent = this.payloadToValue(payload, 30, 'A', appContent, 'IMAX');
                appContent = this.payloadToValue(payload, 34, 'VA', appContent, 'PAPP');
                appContent = this.payloadToValue(payload, 38, 'Wh', appContent, 'HCHC');
                appContent = this.payloadToValue(payload, 42, 'Wh', appContent, 'HCHP');
                appContent = this.payloadToString(payload, 46, 46 + 4, appContent, 'PTEC');
            }
            else if (deviceType === 'ticCbeLinkyTri') {
                appContent = this.payloadToString(payload, 2, 2 + 12, appContent, 'ADCO');
                appContent = this.payloadToValue(payload, 14, 'Wh', appContent, 'BASE');
                appContent = this.payloadToValue(payload, 18, 'A', appContent, 'IINST1');
                appContent = this.payloadToValue(payload, 22, 'A', appContent, 'IINST2');
                appContent = this.payloadToValue(payload, 26, 'A', appContent, 'IINST3');
                appContent = this.payloadToValue(payload, 30, 'A', appContent, 'IMAX1');
                appContent = this.payloadToValue(payload, 34, 'A', appContent, 'IMAX2');
                appContent = this.payloadToValue(payload, 38, 'A', appContent, 'IMAX3');
                appContent = this.payloadToValue(payload, 42, 'W', appContent, 'PMAX');
                appContent = this.payloadToValue(payload, 46, 'VA', appContent, 'PAPP');
            }
            else if (deviceType === 'ticPmePmi') {
                appContent = this.payloadToDate(payload, 2, deviceType, appContent, 'DATE');
                appContent = this.payloadToValue(payload, 8, 'Wh', appContent, 'EA_s');
                appContent = this.payloadToValue(payload, 12, 'varh', appContent, 'ER+_s');
                appContent = this.payloadToValue(payload, 16, 'varh', appContent, 'ER-_s');
                appContent = this.payloadToValue(payload, 20, 'VAh', appContent, 'EAPP_s');
                appContent = this.payloadToString(payload, 24, 24 + 3, appContent, 'PTCOUR1');
                appContent = this.payloadToValue(payload, 27, 'kWh', appContent, 'EAP_s');
                appContent = this.payloadToValue(payload, 31, 'kvarh', appContent, 'ER+P_s');
                appContent = this.payloadToValue(payload, 35, 'kvarh', appContent, 'ER-P_s');
                appContent = this.payloadToValue(payload, 39, 'kWh', appContent, 'EaP-1_s');
                appContent = this.payloadToValue(payload, 43, 'kvarh', appContent, 'ER+P-1_s');
                appContent = this.payloadToValue(payload, 47, 'kvarh', appContent, 'ER-P-1_s');
            }
            return appContent;
        }
        payloadToString(payload, start, end, appContent, label) {
            const charCode = [];
            for (let i = start; i < end; i++) {
                if (payload[i] !== 0x00) {
                    charCode.push(payload[i]);
                }
            }
            const str = String.fromCharCode(...charCode);
            if (str.length > 0) {
                appContent[`${label}`] = str;
            }
            else {
                appContent[`${label}status`] = 'notFound';
            }
            return appContent;
        }
        payloadToValue(payload, start, unit, appContent, label) {
            const val = payload.readUInt32BE(start);
            if (val !== 0x80000000) {
                appContent[`${label}`] = { unit: unit, value: val };
            }
            else {
                appContent[`${label}status`] = 'notFound';
            }
            return appContent;
        }
        p2d(val) {
            return ('0' + val).slice(-2);
        }
        payloadToDate(payload, start, deviceType, appContent, label) {
            let str = '2000-01-01T00:00:00';
            if (deviceType === 'ticPmePmi') {
                // format iso8601 : 2020-4-21T13:43:5
                str =
                    2000 +
                        payload[start + 2] +
                        '-' +
                        this.p2d(payload[start + 1]) +
                        '-' +
                        this.p2d(payload[start + 0]) +
                        'T' +
                        this.p2d(payload[start + 3]) +
                        ':' +
                        this.p2d(payload[start + 4]) +
                        ':' +
                        this.p2d(payload[start + 5]);
            }
            if (str !== '2000-01-01T00:00:00') {
                appContent[`${label}`] = str;
            }
            else {
                appContent[`${label}status`] = 'notFound';
            }
            return appContent;
        }
    }
    codec.Tic0x49Parser = Tic0x49Parser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Tic 0x4a (alarm) frame parser
     */
    class Tic0x4aParser {
        deviceType = 'ticPmePmi|ticCbeLinkyMono|ticCbeLinkyTri';
        frameCode = 0x4a;
        parseFrame(payload, configuration, network) {
            const appContent = { type: '0x4a TIC alarm' };
            appContent['label'] = this.payloadToString(payload, 2, 12);
            appContent['alarmType'] = this.getAlarmTypeText(payload[12]);
            appContent['value'] = this.payloadToString(payload, 13, payload.length);
            return appContent;
        }
        /**
         * Get Threshold Triggering text
         * @param value value
         */
        getAlarmTypeText(value) {
            switch (value) {
                case 0:
                    return 'manualTrigger';
                case 1:
                    return 'labelAppearance';
                case 2:
                    return 'labelDisappearance';
                case 3:
                    return 'highTreshold';
                case 4:
                    return 'lowTreshold';
                case 5:
                    return 'endThresholdAlarm';
                case 6:
                    return 'deltaPositive';
                case 7:
                    return 'deltaNegative';
                default:
                    return '';
            }
        }
        payloadToString(payload, start, end) {
            const charCode = [];
            for (let i = start; i < end; i++) {
                if (payload[i] !== 0x00) {
                    charCode.push(payload[i]);
                }
            }
            const str = String.fromCharCode(...charCode);
            return str.length > 0 ? str : 'notFound';
        }
    }
    codec.Tic0x4aParser = Tic0x4aParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    /**
     * Tic status byte parser
     */
    class TicStatusByteParser {
        deviceType = 'ticPmePmi|ticCbeLinkyMono|ticCbeLinkyTri';
        frameCode = 0;
        parseFrame(payload, configuration, network) {
            const parser = new codec.GenericStatusByteParser();
            const statusContent = parser.parseFrame(payload, configuration);
            // Status byte, applicative flags
            statusContent['configurationInconsistency'] = Boolean(payload[1] & 0x08);
            statusContent['readError'] = Boolean(payload[1] & 0x10);
            return { status: statusContent };
        }
    }
    codec.TicStatusByteParser = TicStatusByteParser;
})(codec || (codec = {}));
var codec;
(function (codec) {
    let PartialDecodingReason;
    (function (PartialDecodingReason) {
        PartialDecodingReason[PartialDecodingReason["NONE"] = 0] = "NONE";
        PartialDecodingReason[PartialDecodingReason["MISSING_NETWORK"] = 1] = "MISSING_NETWORK";
        PartialDecodingReason[PartialDecodingReason["MISSING_CONFIGURATION"] = 2] = "MISSING_CONFIGURATION";
    })(PartialDecodingReason = codec.PartialDecodingReason || (codec.PartialDecodingReason = {}));
})(codec || (codec = {}));
var codec;
(function (codec) {
    class ContentImpl {
        type;
        partialDecoding = codec.PartialDecodingReason.NONE;
        constructor(type = 'Unknown') {
            this.type = type;
        }
        static merge(...contents) {
            if (!contents || contents.length === 0) {
                return null;
            }
            return Object.assign(new ContentImpl(contents[0].type), ...contents);
        }
        merge(...contents) {
            return ContentImpl.merge(this, ...contents);
        }
    }
    codec.ContentImpl = ContentImpl;
})(codec || (codec = {}));
var codec;
(function (codec) {
    class PlateformCommonUtils {
        /**
         * Get Product Mode text
         * @param value value
         */
        static getProductModeText(value) {
            switch (value) {
                case 0:
                    return 'PARK';
                case 1:
                    return 'PRODUCTION';
                case 2:
                    return 'TEST';
                case 3:
                    return 'DEAD';
                default:
                    return '';
            }
        }
    }
    codec.PlateformCommonUtils = PlateformCommonUtils;
})(codec || (codec = {}));
var codec;
(function (codec) {
    let DecoderProducts;
    (function (DecoderProducts) {
        DecoderProducts["analog"] = "Analog";
        DecoderProducts["analog2"] = "Analog 2";
        DecoderProducts["breath"] = "Breath";
        DecoderProducts["comfort"] = "Comfort";
        DecoderProducts["comfort2"] = "Comfort 2";
        DecoderProducts["comfortCo2"] = "Comfort CO2";
        DecoderProducts["comfortSerenity"] = "Comfort Serenity";
        DecoderProducts["drycontacts"] = "Dry Contacts";
        DecoderProducts["drycontacts2"] = "Dry Contacts 2";
        DecoderProducts["deltap"] = "Delta P";
        DecoderProducts["modbus"] = "Modbus";
        DecoderProducts["motion"] = "Motion";
        DecoderProducts["pulse"] = "Pulse";
        DecoderProducts["pulse3"] = "Pulse 3";
        DecoderProducts["pulse4"] = "Pulse 4";
        DecoderProducts["pulse4nbiot"] = "Pulse 4 NB-IoT";
        DecoderProducts["repeater"] = "Repeater";
        DecoderProducts["temp"] = "Temp";
        DecoderProducts["temp3"] = "Temp 3";
        DecoderProducts["temp4"] = "Temp 4";
        DecoderProducts["ticCbeLinkyMono"] = "TIC CBE/LINKY MONO";
        DecoderProducts["ticCbeLinkyTri"] = "TIC CBE/LINKY TRI";
        DecoderProducts["ticPmePmi"] = "TIC PME-PMI";
    })(DecoderProducts = codec.DecoderProducts || (codec.DecoderProducts = {}));
})(codec || (codec = {}));
//# sourceMappingURL=lib.js.map