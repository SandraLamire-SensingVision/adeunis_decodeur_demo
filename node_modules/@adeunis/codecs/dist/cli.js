"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const chalk_1 = __importDefault(require("chalk"));
const cli_table_1 = __importDefault(require("cli-table"));
const fs_1 = require("fs");
const minimist_1 = __importDefault(require("minimist"));
const path_1 = require("path");
const json_2_csv_1 = require("json-2-csv");
const packagejson = require('../package.json');
/**
 * Adeunis codecs CLI
 *
 * Note: to format tables in VSCode when exporting, use regex │\s(\w+)\s+│\s(\w+)\s+│
 */
class AdeunisCodecsCli {
    args;
    options;
    decoder = new codec.Decoder();
    encoder = new codec.Encoder();
    /**
     * Constructor
     * @param _args arguments
     */
    constructor(_args) {
        this.args = _args;
        this.options = (0, minimist_1.default)(_args, {
            string: ['_', 'file', 'devId', 'network', 'deviceType'],
            boolean: ['version', 'csv', 'json'],
            alias: { f: 'file', v: 'version' },
        });
    }
    /**
     * Run
     */
    run() {
        if (this.options['version']) {
            console.log(packagejson.version);
            return;
        }
        switch (this.args[0]) {
            case 'help':
                switch (this.args[1]) {
                    case 'decode':
                        return this.helpDecode();
                    case 'encode':
                        return this.helpEncode(this.options._[2], this.options._[3]);
                    default:
                        return this.help();
                }
            case 'decode':
                if (this.args.length <= 1 || this.options['help'] === true) {
                    return this.helpDecode();
                }
                if (this.options['deviceType'] === undefined) {
                    console.log('\n--deviceType must be defined\n');
                    return this.helpDecode();
                }
                // Example: codec decode --file data.json
                // Number are parsed in this.options._ => not OK
                // TODO: improve against Number.MAX_SAFE_INTEGER
                const frames = this.options._.slice(1).map(o => (typeof o !== 'string' ? o.toString() : o));
                return this.decode(this.options['file'], this.options['devId'], this.options['network'], this.options['deviceType'], frames, this.options['csv'], this.options['json']);
            case 'encode':
                if (this.args.length <= 2) {
                    return this.helpEncode(this.options._[2], this.options._[3]);
                }
                // Example: codec encode 0x10 drycontacts --channel1Output=true
                const options = {};
                for (const key in this.options) {
                    if (Object.prototype.hasOwnProperty.call(this.options, key) && key !== '_') {
                        options[key] = this.options[key];
                    }
                }
                return this.encode(this.options._[1], this.options._[2], this.options['network'], options);
            default:
                return this.showInfo();
        }
    }
    /**
     * Show info
     */
    showInfo() {
        console.log(`${chalk_1.default.bold('Usage:')} ${chalk_1.default.blue('codec')} <command> [<args> ...] [-- <options>]\n`);
        console.log('Available commands:');
        const commandsTable = new cli_table_1.default();
        commandsTable.push({ decode: 'Decode frame' }, { encode: 'Encode frame' }, { help: 'Show help' });
        console.log(commandsTable.toString());
        console.log('Available options:');
        const optionsTable = new cli_table_1.default();
        optionsTable.push({ '-v, --version': 'Print version' }, { '--csv': 'Output in csv format' }, { '--json': 'Output in json format' }, { '...': 'Command specific options' });
        console.log(optionsTable.toString());
    }
    /**
     * Help
     */
    help() {
        console.log(`${chalk_1.default.bold('Usage:')} codec ${chalk_1.default.blue('help')} <command>\n`);
        console.log('Available commands:');
        const table = new cli_table_1.default();
        table.push({ decode: 'Decode frame' }, { encode: 'Encode frame' });
        console.log(table.toString());
    }
    /**
     * Help on decode
     */
    helpDecode() {
        console.log(`${chalk_1.default.bold('Usage:')} codec ${chalk_1.default.blue('decode')}
            --deviceType <device_type> <frame1> [<frame2> ...] \n`);
        console.log('Available device types:');
        const table = new cli_table_1.default({ head: ['Product name', 'deviceType'] });
        const rows = [];
        Object.values(codec.DecoderProducts).forEach(function (val, index) {
            rows.push([val, Object.keys(codec.DecoderProducts)[index]]);
        });
        table.push(...rows);
        console.log(table.toString());
    }
    /**
     * Help on encode
     * @param deviceType device type
     * @param frameCode frame code
     */
    helpEncode(deviceType, frameCode) {
        if (deviceType && frameCode !== 0) {
            console.log('Available encode options:');
            const inputDataTypes = this.encoder.getInputDataTypes(deviceType, frameCode);
            const table = new cli_table_1.default({ head: ['Option', 'Type'] });
            const rows = [];
            for (const key in inputDataTypes) {
                if (Object.prototype.hasOwnProperty.call(inputDataTypes, key)) {
                    rows.push([key, inputDataTypes[key]]);
                }
            }
            table.push(...rows);
            console.log(table.toString());
        }
        else {
            console.log(`${chalk_1.default.bold('Usage:')} codec ${chalk_1.default.blue('encode')} <device_type> <frame_code>` +
                ` [--network lora868|sigfox] [-- <encode_options>]\n`);
            console.log('Available device types and frame codes:');
            const supported = this.encoder.getSupported();
            const table = new cli_table_1.default({ head: ['Device type', 'Frame code'] });
            const rows = supported.map(sf => [sf.deviceType, sf.frameCode === -1 ? 'any' : '0x' + sf.frameCode.toString(16)]);
            table.push(...rows);
            console.log(table.toString());
        }
    }
    /**
     * Decode
     * @param filePath file path to parse
     * @param devId device ID
     * @param network network: lora868 or sigfox
     * @param frames frames to decode
     * @param deviceType device type
     */
    decode(filePath, devId, network, deviceType, frames, csvOutput, jsonOutput) {
        // Fix => change minimist to keep 0 before frame value
        if (deviceType === 'repeater') {
            frames = frames.map(frame => '0'.concat(frame));
        }
        if (filePath) {
            const fileString = (0, fs_1.readFileSync)((0, path_1.join)(__dirname, filePath), 'utf8');
            const data = JSON.parse(fileString);
            if (!data.sections) {
                process.exit();
            }
            for (const section of data.sections) {
                if (section.enabled) {
                    console.log(`
======================================== ${section.title} ========================================`);
                    this.printDecoded(section.frames, devId, network, deviceType, csvOutput, jsonOutput);
                }
            }
        }
        else if (frames && frames.length > 0) {
            this.printDecoded(frames, devId, network, deviceType, csvOutput, jsonOutput);
        }
    }
    /**
     * Encode
     * @param deviceType device type
     * @param frameCode frame code
     * @param network network: lora868 or sigfox
     * @param data data
     */
    encode(deviceType, frameCode, network, data) {
        const payloadString = this.encoder.encode(deviceType, frameCode, network, data);
        console.log(payloadString);
    }
    /**
     * Print decoded frames
     * @param frames frames to print
     * @param devId device ID
     * @param network network: lora868 or sigfox
     * @param deviceType device type
     */
    printDecoded(frames, devId, network, deviceType, csvOutput, jsonOutput) {
        this.decoder.clearStoredData();
        if (deviceType) {
            this.decoder.setDeviceType(deviceType);
        }
        for (const payloadString of frames) {
            const content = this.decoder.decode(payloadString, devId, network);
            if (csvOutput) {
                const options = {
                    delimiter: {
                        wrap: '"',
                        field: ';',
                        eol: '\n', // Newline delimiter
                    },
                    prependHeader: true,
                    sortHeader: false,
                    excelBOM: true,
                    trimHeaderFields: true,
                    trimFieldValues: true,
                    keys: undefined,
                };
                console.log((0, json_2_csv_1.json2csv)(content, options));
                continue;
            }
            if (jsonOutput) {
                console.log(JSON.stringify(content));
                continue;
            }
            const table = new cli_table_1.default();
            for (const key in content) {
                if (Object.prototype.hasOwnProperty.call(content, key)) {
                    const row = {};
                    row[key] = this.defaultWhenNil(JSON.stringify(content[key]), '');
                    table.push(row);
                }
            }
            console.log(table.toString());
        }
    }
    /**
     * Use default value when null or undefined
     * @param value value to check
     * @param defaultValue default value
     */
    defaultWhenNil(value, defaultValue) {
        if (value === null || value === undefined) {
            return defaultValue;
        }
        return value;
    }
}
module.exports = AdeunisCodecsCli;
//# sourceMappingURL=cli.js.map